# 1 "dfa.c"
# 1 "/home/landq/Desktop/tool/real_world/grep-2.25/src//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "dfa.c"
# 23 "dfa.c"
# 1 "../config.h" 1
# 24 "dfa.c" 2

# 1 "dfa.h" 1
# 21 "dfa.h"
# 1 "../lib/regex.h" 1
# 24 "../lib/regex.h"
# 1 "../lib/sys/types.h" 1
# 20 "../lib/sys/types.h"
       
# 21 "../lib/sys/types.h" 3







# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 367 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 410 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 411 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 368 "/usr/include/features.h" 2 3 4
# 391 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 392 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "../lib/time.h" 1 3 4
# 20 "../lib/time.h" 3 4
       
# 21 "../lib/time.h" 3
# 35 "../lib/time.h" 3
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 36 "../lib/time.h" 2 3
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "../lib/time.h" 1 3 4
# 20 "../lib/time.h" 3 4
       
# 21 "../lib/time.h" 3
# 35 "../lib/time.h" 3
# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 36 "../lib/time.h" 2 3
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4

# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 125 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    signed char __rwelision;




    unsigned char __pad1[7];


    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 220 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 29 "../lib/sys/types.h" 2 3
# 25 "../lib/regex.h" 2
# 56 "../lib/regex.h"

# 56 "../lib/regex.h"
typedef unsigned int __re_size_t;
typedef unsigned long int __re_long_size_t;







typedef long int s_reg_t;
typedef unsigned long int active_reg_t;






typedef unsigned long int reg_syntax_t;
# 212 "../lib/regex.h"
extern reg_syntax_t re_syntax_options;
# 347 "../lib/regex.h"
typedef enum
{
  _REG_ENOSYS = -1,
  _REG_NOERROR = 0,
  _REG_NOMATCH,



  _REG_BADPAT,
  _REG_ECOLLATE,
  _REG_ECTYPE,
  _REG_EESCAPE,
  _REG_ESUBREG,
  _REG_EBRACK,
  _REG_EPAREN,
  _REG_EBRACE,
  _REG_BADBR,
  _REG_ERANGE,
  _REG_ESPACE,
  _REG_BADRPT,


  _REG_EEND,
  _REG_ESIZE,
  _REG_ERPAREN
} reg_errcode_t;
# 414 "../lib/regex.h"
struct re_pattern_buffer
{


  struct re_dfa_t *buffer;


  __re_long_size_t allocated;


  __re_long_size_t used;


  reg_syntax_t syntax;




  char *fastmap;





  unsigned char * translate;


  size_t re_nsub;





  unsigned can_be_null : 1;
# 458 "../lib/regex.h"
  unsigned regs_allocated : 2;



  unsigned fastmap_accurate : 1;



  unsigned no_sub : 1;



  unsigned not_bol : 1;


  unsigned not_eol : 1;


  unsigned newline_anchor : 1;
};

typedef struct re_pattern_buffer regex_t;
# 491 "../lib/regex.h"
typedef int regoff_t;






struct re_registers
{
  __re_size_t num_regs;
  regoff_t *start;
  regoff_t *end;
};
# 518 "../lib/regex.h"
typedef struct
{
  regoff_t rm_so;
  regoff_t rm_eo;
} regmatch_t;






extern reg_syntax_t re_set_syntax (reg_syntax_t __syntax);
# 539 "../lib/regex.h"
extern const char *re_compile_pattern (const char *__pattern, size_t __length,
           struct re_pattern_buffer *__buffer);





extern int re_compile_fastmap (struct re_pattern_buffer *__buffer);







extern regoff_t re_search (struct re_pattern_buffer *__buffer,
      const char *__string, regoff_t __length,
      regoff_t __start, regoff_t __range,
      struct re_registers *__regs);




extern regoff_t re_search_2 (struct re_pattern_buffer *__buffer,
        const char *__string1, regoff_t __length1,
        const char *__string2, regoff_t __length2,
        regoff_t __start, regoff_t __range,
        struct re_registers *__regs,
        regoff_t __stop);




extern regoff_t re_match (struct re_pattern_buffer *__buffer,
     const char *__string, regoff_t __length,
     regoff_t __start, struct re_registers *__regs);



extern regoff_t re_match_2 (struct re_pattern_buffer *__buffer,
       const char *__string1, regoff_t __length1,
       const char *__string2, regoff_t __length2,
       regoff_t __start, struct re_registers *__regs,
       regoff_t __stop);
# 597 "../lib/regex.h"
extern void re_set_registers (struct re_pattern_buffer *__buffer,
         struct re_registers *__regs,
         __re_size_t __num_regs,
         regoff_t *__starts, regoff_t *__ends);
# 640 "../lib/regex.h"
extern int regcomp (regex_t *__restrict __preg,
      const char *__restrict __pattern,
      int __cflags);

extern int regexec (const regex_t *__restrict __preg,
      const char *__restrict __string, size_t __nmatch,
      regmatch_t __pmatch[__restrict],
      int __eflags);

extern size_t regerror (int __errcode, const regex_t *__restrict __preg,
   char *__restrict __errbuf, size_t __errbuf_size);

extern void regfree (regex_t *__preg);
# 22 "dfa.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdbool.h" 1 3 4
# 23 "dfa.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4

# 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef int wchar_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 24 "dfa.h" 2

# 1 "../lib/xalloc.h" 1
# 21 "../lib/xalloc.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 22 "../lib/xalloc.h" 2

# 1 "../lib/xalloc-oversized.h" 1
# 21 "../lib/xalloc-oversized.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 22 "../lib/xalloc-oversized.h" 2
# 24 "../lib/xalloc.h" 2





# 56 "../lib/xalloc.h"

# 56 "../lib/xalloc.h"
extern _Noreturn void xalloc_die (void);

void *xmalloc (size_t s)
      __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1)));
void *xzalloc (size_t s)
      __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1)));
void *xcalloc (size_t n, size_t s)
      __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2)));
void *xrealloc (void *p, size_t s)
      __attribute__ ((__alloc_size__ (2)));
void *x2realloc (void *p, size_t *pn);
void *xmemdup (void const *p, size_t s)
      __attribute__ ((__alloc_size__ (2)));
char *xstrdup (char const *str)
      __attribute__ ((__malloc__));
# 101 "../lib/xalloc.h"
inline void *xnmalloc (size_t n, size_t s)
                    __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2)));
inline void *
xnmalloc (size_t n, size_t s)
{
  if (({ size_t __xalloc_size; __builtin_mul_overflow (n, s, &__xalloc_size); }))
    xalloc_die ();
  return xmalloc (n * s);
}




inline void *xnrealloc (void *p, size_t n, size_t s)
                    __attribute__ ((__alloc_size__ (2, 3)));
inline void *
xnrealloc (void *p, size_t n, size_t s)
{
  if (({ size_t __xalloc_size; __builtin_mul_overflow (n, s, &__xalloc_size); }))
    xalloc_die ();
  return xrealloc (p, n * s);
}
# 178 "../lib/xalloc.h"
inline void *
x2nrealloc (void *p, size_t *pn, size_t s)
{
  size_t n = *pn;

  if (! p)
    {
      if (! n)
        {




          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };

          n = DEFAULT_MXFAST / s;
          n += !n;
        }
    }
  else
    {




      if ((size_t) -1 / 3 * 2 / s <= n)
        xalloc_die ();
      n += n / 2 + 1;
    }

  *pn = n;
  return xrealloc (p, n * s);
}




inline char *xcharalloc (size_t n)
                    __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1)));
inline char *
xcharalloc (size_t n)
{
  return ((char *) (sizeof (char) == 1 ? xmalloc (n) : xnmalloc (n, sizeof (char))));
}
# 262 "../lib/xalloc.h"

# 26 "dfa.h" 2



struct dfamust
{
  
# 31 "dfa.h" 3 4
 _Bool 
# 31 "dfa.h"
      exact;
  
# 32 "dfa.h" 3 4
 _Bool 
# 32 "dfa.h"
      begline;
  
# 33 "dfa.h" 3 4
 _Bool 
# 33 "dfa.h"
      endline;
  char *must;
};


struct dfa;






extern struct dfa *dfaalloc (void) __attribute__ ((__malloc__));


extern struct dfamust *dfamust (struct dfa const *);


extern void dfamustfree (struct dfamust *);




extern void dfasyntax (reg_syntax_t, int, unsigned char);




extern void dfacomp (char const *, size_t, struct dfa *, int);
# 75 "dfa.h"
extern char *dfaexec (struct dfa *d, char const *begin, char *end,
                      int newline, size_t *count, int *backref);





extern struct dfa *dfasuperset (struct dfa const *d) __attribute__ ((__pure__));


extern 
# 85 "dfa.h" 3 4
      _Bool 
# 85 "dfa.h"
           dfaisfast (struct dfa const *) __attribute__ ((__pure__));


extern void dfafree (struct dfa *);




extern void dfainit (struct dfa *);


extern void dfaparse (char const *, size_t, struct dfa *);



extern void dfaanalyze (struct dfa *, int);



extern void dfastate (ptrdiff_t, struct dfa *, ptrdiff_t []);







extern void dfawarn (const char *);




extern _Noreturn void dfaerror (const char *);

extern int using_utf8 (void);
# 26 "dfa.c" 2

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4




# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 28 "dfa.c" 2
# 1 "../lib/ctype.h" 1
# 29 "../lib/ctype.h"
       
# 30 "../lib/ctype.h" 3





# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));






extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 257 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 258 "/usr/include/ctype.h" 2 3 4
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 347 "/usr/include/ctype.h" 3 4

# 36 "../lib/ctype.h" 2 3
# 29 "dfa.c" 2
# 1 "../lib/stdio.h" 1
# 20 "../lib/stdio.h"
       
# 21 "../lib/stdio.h" 3
# 43 "../lib/stdio.h" 3
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "../lib/wchar.h" 1 3 4
# 30 "../lib/wchar.h" 3 4
       
# 31 "../lib/wchar.h" 3
# 52 "../lib/wchar.h" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 53 "../lib/wchar.h" 2 3
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;





typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 173 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 333 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 429 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 459 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 640 "/usr/include/stdio.h" 3 4

# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 872 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 942 "/usr/include/stdio.h" 3 4

# 44 "../lib/stdio.h" 2 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h" 1 3 4
# 52 "../lib/stdio.h" 2 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 54 "../lib/stdio.h" 2 3




# 1 "../lib/sys/types.h" 1 3
# 20 "../lib/sys/types.h" 3
       
# 21 "../lib/sys/types.h" 3
# 59 "../lib/stdio.h" 2 3
# 552 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 567 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 610 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 661 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 676 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 691 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 731 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 901 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy
                                                                      ;
# 927 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;
# 939 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 953 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1189 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1212 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1226 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1240 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1342 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1525 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy
                                                                    ;

extern int _gl_cxxalias_dummy;
# 1580 "../lib/stdio.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 30 "dfa.c" 2
# 1 "../lib/stdlib.h" 1
# 20 "../lib/stdlib.h"
       
# 21 "../lib/stdlib.h" 3
# 36 "../lib/stdlib.h" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "../lib/sys/types.h" 1 3 4
# 20 "../lib/sys/types.h" 3 4
       
# 21 "../lib/sys/types.h" 3
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "../lib/alloca.h" 1 3 4
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 629 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 651 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 673 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 683 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 693 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 811 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 898 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 955 "/usr/include/stdlib.h" 2 3 4
# 967 "/usr/include/stdlib.h" 3 4

# 37 "../lib/stdlib.h" 2 3





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 43 "../lib/stdlib.h" 2 3
# 607 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 627 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1065 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1203 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy
                                                                ;
extern int _gl_cxxalias_dummy;
# 1228 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy
                                                                ;
extern int _gl_cxxalias_dummy;
# 1291 "../lib/stdlib.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 31 "dfa.c" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 152 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed/limits.h" 2 3 4
# 32 "dfa.c" 2
# 1 "../lib/string.h" 1
# 20 "../lib/string.h"
       
# 21 "../lib/string.h" 3
# 41 "../lib/string.h" 3
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 106 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 117 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 206 "/usr/include/string.h" 3 4

# 231 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 258 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 272 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 310 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 337 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 368 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 433 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 484 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 512 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 599 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 658 "/usr/include/string.h" 3 4

# 42 "../lib/string.h" 2 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 50 "../lib/string.h" 2 3
# 438 "../lib/string.h" 3
extern int _gl_cxxalias_dummy

                                                                             ;



extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy
                                                          ;
# 502 "../lib/string.h" 3
extern int _gl_cxxalias_dummy

                               ;
extern int _gl_cxxalias_dummy;
# 524 "../lib/string.h" 3
extern int _gl_cxxalias_dummy

                                                                  ;


extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
# 579 "../lib/string.h" 3
extern int _gl_cxxalias_dummy
                                                                     ;
extern int _gl_cxxalias_dummy;
# 691 "../lib/string.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 769 "../lib/string.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 903 "../lib/string.h" 3
extern int _gl_cxxalias_dummy

                                                                                 ;



extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy
                                                              ;
# 1060 "../lib/string.h" 3
extern size_t mbslen (const char *string) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))

                                                        ;
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 1125 "../lib/string.h" 3
extern char * mbsstr (const char *haystack, const char *needle)
     __attribute__ ((__pure__))
     __attribute__ ((__nonnull__ (1, 2)));
# 1137 "../lib/string.h" 3
extern int mbscasecmp (const char *s1, const char *s2)
     __attribute__ ((__pure__))
     __attribute__ ((__nonnull__ (1, 2)));
# 1276 "../lib/string.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 33 "dfa.c" 2
# 1 "../lib/locale.h" 1
# 19 "../lib/locale.h"
       
# 20 "../lib/locale.h" 3
# 38 "../lib/locale.h" 3
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 50 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));


# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern __locale_t uselocale (__locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 39 "../lib/locale.h" 2 3







# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 47 "../lib/locale.h" 2 3
# 466 "../lib/locale.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 34 "dfa.c" 2
# 47 "dfa.c"
# 1 "../lib/gettext.h" 1
# 25 "../lib/gettext.h"
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4





extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/libintl.h" 3 4

# 26 "../lib/gettext.h" 2
# 141 "../lib/gettext.h"

# 141 "../lib/gettext.h"
__inline





static const char *
pgettext_aux (const char *domain,
              const char *msg_ctxt_id, const char *msgid,
              int category)
{
  const char *translation = dcgettext (domain, msg_ctxt_id, category);
  if (translation == msg_ctxt_id)
    return msgid;
  else
    return translation;
}


__inline





static const char *
npgettext_aux (const char *domain,
               const char *msg_ctxt_id, const char *msgid,
               const char *msgid_plural, unsigned long int n,
               int category)
{
  const char *translation =
    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);
  if (translation == msg_ctxt_id || translation == msgid_plural)
    return (n == 1 ? msgid : msgid_plural);
  else
    return translation;
}





# 1 "../lib/string.h" 1
# 20 "../lib/string.h"
       
# 21 "../lib/string.h" 3
# 185 "../lib/gettext.h" 2
# 203 "../lib/gettext.h"
__inline





static const char *
dcpgettext_expr (const char *domain,
                 const char *msgctxt, const char *msgid,
                 int category)
{
  size_t msgctxt_len = strlen (msgctxt) + 1;
  size_t msgid_len = strlen (msgid) + 1;
  const char *translation;

  char msg_ctxt_id[msgctxt_len + msgid_len];
# 227 "../lib/gettext.h"
    {
      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
      msg_ctxt_id[msgctxt_len - 1] = '\004';
      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
      translation = dcgettext (domain, msg_ctxt_id, category);




      if (translation != msg_ctxt_id)
        return translation;
    }
  return msgid;
}







__inline





static const char *
dcnpgettext_expr (const char *domain,
                  const char *msgctxt, const char *msgid,
                  const char *msgid_plural, unsigned long int n,
                  int category)
{
  size_t msgctxt_len = strlen (msgctxt) + 1;
  size_t msgid_len = strlen (msgid) + 1;
  const char *translation;

  char msg_ctxt_id[msgctxt_len + msgid_len];
# 273 "../lib/gettext.h"
    {
      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);
      msg_ctxt_id[msgctxt_len - 1] = '\004';
      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);
      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);




      if (!(translation == msg_ctxt_id || translation == msgid_plural))
        return translation;
    }
  return (n == 1 ? msgid : msgid_plural);
}
# 48 "dfa.c" 2


# 1 "../lib/wchar.h" 1
# 30 "../lib/wchar.h"
       
# 31 "../lib/wchar.h" 3
# 84 "../lib/wchar.h" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 36 "/usr/include/wchar.h" 3 4
# 1 "../lib/stdio.h" 1 3 4
# 20 "../lib/stdio.h" 3 4
       
# 21 "../lib/stdio.h" 3
# 37 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 357 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4

# 357 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






# 132 "/usr/include/wchar.h" 3 4





struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wcsdup (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));










extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));






extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 269 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));
# 280 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcslen (const wchar_t *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));

# 302 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));





extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));




# 323 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));






extern wint_t btowc (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wctob (wint_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int mbsinit (const mbstate_t *__ps) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) __attribute__ ((__nothrow__ , __leaf__));


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));

# 408 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) __attribute__ ((__nothrow__ , __leaf__));






extern int wcwidth (wchar_t __c) __attribute__ ((__nothrow__ , __leaf__));



extern int wcswidth (const wchar_t *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__));







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) __attribute__ ((__nothrow__ , __leaf__));






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) __attribute__ ((__nothrow__ , __leaf__));
# 533 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__));

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) __attribute__ ((__nothrow__ , __leaf__));



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__));






extern int fwide (__FILE *__fp, int __mode) __attribute__ ((__nothrow__ , __leaf__));






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     __attribute__ ((__nothrow__ , __leaf__)) ;
# 683 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) ;
# 739 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 804 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 830 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 840 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 894 "/usr/include/wchar.h" 3 4

# 85 "../lib/wchar.h" 2 3
# 469 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 495 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 520 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 539 "../lib/wchar.h" 3
extern size_t rpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)
                                                                         ;
extern int _gl_cxxalias_dummy
                                                                         ;
# 551 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;
# 568 "../lib/wchar.h" 3
extern size_t rpl_mbrlen (const char *s, size_t n, mbstate_t *ps);
extern int _gl_cxxalias_dummy;






extern int _gl_cxxalias_dummy;
# 605 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy

                                  ;

extern int _gl_cxxalias_dummy;
# 667 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 766 "../lib/wchar.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 51 "dfa.c" 2
# 1 "../lib/wctype.h" 1
# 32 "../lib/wctype.h"
       
# 33 "../lib/wctype.h" 3
# 42 "../lib/wctype.h" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 43 "../lib/wctype.h" 2 3
# 1 "../lib/stdio.h" 1 3
# 20 "../lib/stdio.h" 3
       
# 21 "../lib/stdio.h" 3
# 44 "../lib/wctype.h" 2 3
# 1 "../lib/time.h" 1 3
# 20 "../lib/time.h" 3
       
# 21 "../lib/time.h" 3
# 41 "../lib/time.h" 3
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 88 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 89 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 42 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 42 "../lib/time.h" 2 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h" 1 3 4
# 45 "../lib/time.h" 2 3
# 404 "../lib/time.h" 3
struct __time_t_must_be_integral {
  unsigned int __floating_time_t_unsupported : (time_t) 1;
};
# 512 "../lib/time.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 527 "../lib/time.h" 3
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 45 "../lib/wctype.h" 2 3
# 1 "../lib/wchar.h" 1 3
# 30 "../lib/wchar.h" 3
       
# 31 "../lib/wchar.h" 3
# 46 "../lib/wctype.h" 2 3
# 59 "../lib/wctype.h" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "../lib/wchar.h" 1 3 4
# 30 "../lib/wchar.h" 3 4
       
# 31 "../lib/wchar.h" 3
# 52 "../lib/wchar.h" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 53 "../lib/wchar.h" 2 3
# 34 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};












extern int iswalnum (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));





extern int iswalpha (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));


extern int iswcntrl (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));



extern int iswdigit (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));



extern int iswgraph (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));




extern int iswlower (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));


extern int iswprint (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));




extern int iswpunct (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));




extern int iswspace (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));




extern int iswupper (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));




extern int iswxdigit (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));





extern int iswblank (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) __attribute__ ((__nothrow__ , __leaf__));



extern int iswctype (wint_t __wc, wctype_t __desc) __attribute__ ((__nothrow__ , __leaf__));










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));


extern wint_t towupper (wint_t __wc) __attribute__ ((__nothrow__ , __leaf__));



# 213 "/usr/include/wctype.h" 3 4





extern wctrans_t wctrans (const char *__property) __attribute__ ((__nothrow__ , __leaf__));


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) __attribute__ ((__nothrow__ , __leaf__));








extern int iswalnum_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));





extern int iswalpha_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));



extern int iswdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));



extern int iswgraph_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));


extern int iswprint_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswpunct_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswspace_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




extern int iswblank_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     __attribute__ ((__nothrow__ , __leaf__));


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) __attribute__ ((__nothrow__ , __leaf__));




# 60 "../lib/wctype.h" 2 3
# 68 "../lib/wctype.h" 3

# 692 "../lib/wctype.h" 3
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;





extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
# 754 "../lib/wctype.h" 3
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
# 768 "../lib/wctype.h" 3
extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;

extern int _gl_cxxalias_dummy;
extern int _gl_cxxalias_dummy;
# 813 "../lib/wctype.h" 3

# 52 "dfa.c" 2
# 62 "dfa.c"

# 62 "dfa.c"
enum { NOTCHAR = 1 << 8 };



typedef unsigned int charclass_word;



enum { CHARCLASS_WORD_BITS = 32 };






enum
{
  CHARCLASS_WORDS = (NOTCHAR + CHARCLASS_WORD_BITS - 1) / CHARCLASS_WORD_BITS
};


typedef charclass_word charclass[CHARCLASS_WORDS];




static unsigned char
to_uchar (char ch)
{
  return ch;
}
# 161 "dfa.c"
typedef ptrdiff_t token;


enum
{
  END = -1,







  EMPTY = NOTCHAR,


  BACKREF,







  BEGLINE,



  ENDLINE,


  BEGWORD,



  ENDWORD,


  LIMWORD,



  NOTLIMWORD,



  QMARK,



  STAR,



  PLUS,



  REPMN,



  CAT,




  OR,


  LPAREN,


  RPAREN,

  ANYCHAR,



  MBCSET,


  WCHAR,


  CSET


};






typedef struct
{
  size_t index;
  unsigned int constraint;
} position;


typedef struct
{
  position *elems;
  size_t nelem;
  size_t alloc;
} position_set;


typedef struct
{
  size_t *elems;
  size_t nelem;
} leaf_set;




typedef struct
{
  size_t hash;
  position_set elems;
  unsigned char context;
  unsigned short constraint;
  token first_end;
  position_set mbps;


} dfa_state;



typedef ptrdiff_t state_num;



struct mb_char_classes
{
  ptrdiff_t cset;
  
# 301 "dfa.c" 3 4
 _Bool 
# 301 "dfa.c"
      invert;
  wchar_t *chars;
  size_t nchars;
};


struct dfa
{

  charclass *charclasses;
  size_t cindex;
  size_t calloc;


  token *tokens;
  size_t tindex;
  size_t talloc;
  size_t depth;


  size_t nleaves;
  size_t nregexps;

  
# 324 "dfa.c" 3 4
 _Bool 
# 324 "dfa.c"
      fast;
  
# 325 "dfa.c" 3 4
 _Bool 
# 325 "dfa.c"
      multibyte;
  token utf8_anychar_classes[5];
  mbstate_t mbs;


  char *(*dfaexec) (struct dfa *, char const *, char *, int, size_t *, int *);
# 351 "dfa.c"
  int *multibyte_prop;


  struct mb_char_classes *mbcsets;
  size_t nmbcsets;
  size_t mbcsets_alloc;


  struct dfa *superset;


  dfa_state *states;
  state_num sindex;
  size_t salloc;


  position_set *follows;






  
# 374 "dfa.c" 3 4
 _Bool 
# 374 "dfa.c"
      searchflag;
# 383 "dfa.c"
  state_num tralloc;

  int trcount;

  int min_trcount;



  state_num **trans;






  state_num **fails;

  int *success;

  state_num *newlines;






  state_num initstate_letter;
  state_num initstate_others;
  position_set mb_follows;

  int *mb_match_lens;


};
# 427 "dfa.c"
static void regexp (void);




static wint_t mbrtowc_cache[NOTCHAR];
# 451 "dfa.c"
static size_t
mbs_to_wchar (wint_t *pwc, char const *s, size_t n, struct dfa *d)
{
  unsigned char uc = s[0];
  wint_t wc = mbrtowc_cache[uc];

  if (wc == 
# 457 "dfa.c" 3 4
           (0xffffffffu)
# 457 "dfa.c"
               )
    {
      wchar_t wch;
      size_t nbytes = 
# 460 "dfa.c" 3
                     rpl_mbrtowc 
# 460 "dfa.c"
                             (&wch, s, n, &d->mbs);
      if (0 < nbytes && nbytes < (size_t) -2)
        {
          *pwc = wch;
          return nbytes;
        }
      memset (&d->mbs, 0, sizeof d->mbs);
    }

  *pwc = wc;
  return 1;
}
# 553 "dfa.c"
static 
# 553 "dfa.c" 3 4
      _Bool

# 554 "dfa.c"
tstbit (unsigned int b, charclass const c)
{
  return c[b / CHARCLASS_WORD_BITS] >> b % CHARCLASS_WORD_BITS & 1;
}

static void
setbit (unsigned int b, charclass c)
{
  c[b / CHARCLASS_WORD_BITS] |= (charclass_word) 1 << b % CHARCLASS_WORD_BITS;
}

static void
clrbit (unsigned int b, charclass c)
{
  c[b / CHARCLASS_WORD_BITS] &= ~((charclass_word) 1
                                  << b % CHARCLASS_WORD_BITS);
}

static void
copyset (charclass const src, charclass dst)
{
  memcpy (dst, src, sizeof (charclass));
}

static void
zeroset (charclass s)
{
  memset (s, 0, sizeof (charclass));
}

static void
notset (charclass s)
{
  int i;

  for (i = 0; i < CHARCLASS_WORDS; ++i)
    s[i] = (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1) & ~s[i];
}

static 
# 593 "dfa.c" 3 4
      _Bool

# 594 "dfa.c"
equal (charclass const s1, charclass const s2)
{
  return memcmp (s1, s2, sizeof (charclass)) == 0;
}
# 607 "dfa.c"
static void *
maybe_realloc (void *ptr, size_t nitems, size_t *nalloc, size_t itemsize)
{
  if (nitems < *nalloc)
    return ptr;
  *nalloc = nitems;
  return x2nrealloc (ptr, nalloc, itemsize);
}


static size_t
dfa_charclass_index (struct dfa *d, charclass const s)
{
  size_t i;

  for (i = 0; i < d->cindex; ++i)
    if (equal (s, d->charclasses[i]))
      return i;
  d->charclasses = maybe_realloc (d->charclasses, d->cindex, &d->calloc,
                                  sizeof *d->charclasses);
  ++d->cindex;
  copyset (s, d->charclasses[i]);
  return i;
}


static struct dfa *dfa;


static size_t
charclass_index (charclass const s)
{
  return dfa_charclass_index (dfa, s);
}


static reg_syntax_t syntax_bits, syntax_bits_set;


static 
# 646 "dfa.c" 3 4
      _Bool 
# 646 "dfa.c"
           case_fold;


static unsigned char eolbyte;


static int sbit[NOTCHAR];


static charclass letters;


static charclass newline;

static 
# 660 "dfa.c" 3 4
      _Bool

# 661 "dfa.c"
unibyte_word_constituent (unsigned char c)
{
  return mbrtowc_cache[c] != 
# 663 "dfa.c" 3 4
                            (0xffffffffu) 
# 663 "dfa.c"
                                 && (
# 663 "dfa.c" 3 4
                                     ((*__ctype_b_loc ())[(int) ((
# 663 "dfa.c"
                                     c
# 663 "dfa.c" 3 4
                                     ))] & (unsigned short int) _ISalnum) 
# 663 "dfa.c"
                                                 || (c) == '_');
}

static int
char_context (unsigned char c)
{
  if (c == eolbyte)
    return 4;
  if (unibyte_word_constituent (c))
    return 2;
  return 1;
}

static int
wchar_context (wint_t wc)
{
  if (wc == (wchar_t) eolbyte || wc == 0)
    return 4;
  if (wc == L'_' || iswalnum (wc))
    return 2;
  return 1;
}


void
dfasyntax (reg_syntax_t bits, int fold, unsigned char eol)
{
  int i;
  syntax_bits_set = 1;
  syntax_bits = bits;
  case_fold = fold != 0;
  eolbyte = eol;

  for (i = 
# 696 "dfa.c" 3 4
          (-0x7f - 1)
# 696 "dfa.c"
                  ; i <= 0x7f; ++i)
    {
      char c = i;
      unsigned char uc = i;
      mbstate_t s = { 0 };
      wchar_t wc;
      mbrtowc_cache[uc] = 
# 702 "dfa.c" 3
                         rpl_mbrtowc 
# 702 "dfa.c"
                                 (&wc, &c, 1, &s) <= 1 ? wc : 
# 702 "dfa.c" 3 4
                                                              (0xffffffffu)
# 702 "dfa.c"
                                                                  ;


      sbit[uc] = char_context (uc);
      switch (sbit[uc])
        {
        case 2:
          setbit (uc, letters);
          break;
        case 4:
          setbit (uc, newline);
          break;
        }
    }
}






static 
# 723 "dfa.c" 3 4
      _Bool

# 724 "dfa.c"
setbit_wc (wint_t wc, charclass c)
{
  int b = wctob (wc);
  if (b == 
# 727 "dfa.c" 3 4
          (-1)
# 727 "dfa.c"
             )
    return 
# 728 "dfa.c" 3 4
          0
# 728 "dfa.c"
               ;

  setbit (b, c);
  return 
# 731 "dfa.c" 3 4
        1
# 731 "dfa.c"
            ;
}



static void
setbit_case_fold_c (int b, charclass c)
{
  int ub = toupper (b);
  int i;
  for (i = 0; i < NOTCHAR; i++)
    if (toupper (i) == ub)
      setbit (i, c);
}





int
using_utf8 (void)
{
  static int utf8 = -1;
  if (utf8 < 0)
    {
      wchar_t wc;
      mbstate_t mbs = { 0 };
      utf8 = 
# 758 "dfa.c" 3
            rpl_mbrtowc 
# 758 "dfa.c"
                    (&wc, "\xc4\x80", 2, &mbs) == 2 && wc == 0x100;
    }
  return utf8;
}






static 
# 768 "dfa.c" 3 4
      _Bool

# 769 "dfa.c"
using_simple_locale (void)
{




  enum { native_c_charset =
    ('\b' == 8 && '\t' == 9 && '\n' == 10 && '\v' == 11 && '\f' == 12
     && '\r' == 13 && ' ' == 32 && '!' == 33 && '"' == 34 && '#' == 35
     && '%' == 37 && '&' == 38 && '\'' == 39 && '(' == 40 && ')' == 41
     && '*' == 42 && '+' == 43 && ',' == 44 && '-' == 45 && '.' == 46
     && '/' == 47 && '0' == 48 && '9' == 57 && ':' == 58 && ';' == 59
     && '<' == 60 && '=' == 61 && '>' == 62 && '?' == 63 && 'A' == 65
     && 'Z' == 90 && '[' == 91 && '\\' == 92 && ']' == 93 && '^' == 94
     && '_' == 95 && 'a' == 97 && 'z' == 122 && '{' == 123 && '|' == 124
     && '}' == 125 && '~' == 126)
  };

  if (! native_c_charset || dfa->multibyte)
    return 
# 788 "dfa.c" 3 4
          0
# 788 "dfa.c"
               ;
  else
    {
      static int unibyte_c = -1;
      if (unibyte_c < 0)
        {
          char const *locale = setlocale (
# 794 "dfa.c" 3 4
                                         6
# 794 "dfa.c"
                                               , 
# 794 "dfa.c" 3 4
                                                 ((void *)0)
# 794 "dfa.c"
                                                     );
          unibyte_c = (!locale
                       || (strcmp (locale, "C") == 0)
                       || (strcmp (locale, "POSIX") == 0));
        }
      return unibyte_c;
    }
}






static char const *lexptr;
static size_t lexleft;
static token lasttok;
static 
# 811 "dfa.c" 3 4
      _Bool 
# 811 "dfa.c"
           laststart;

static size_t parens;
static int minrep, maxrep;

static int cur_mb_len = 1;


static wint_t wctok;
# 862 "dfa.c"
static short const lonesome_lower[] =
  {
    0x00B5, 0x0131, 0x017F, 0x01C5, 0x01C8, 0x01CB, 0x01F2, 0x0345,
    0x03C2, 0x03D0, 0x03D1, 0x03D5, 0x03D6, 0x03F0, 0x03F1,



    0x03F2,

    0x03F5, 0x1E9B, 0x1FBE,
  };





enum
{ CASE_FOLDED_BUFSIZE = 2 + sizeof lonesome_lower / sizeof *lonesome_lower };




static unsigned int
case_folded_counterparts (wchar_t c, wchar_t folded[CASE_FOLDED_BUFSIZE])
{
  unsigned int i;
  unsigned int n = 0;
  wint_t uc = towupper (c);
  wint_t lc = towlower (uc);
  if (uc != c)
    folded[n++] = uc;
  if (lc != uc && lc != c && towupper (lc) == uc)
    folded[n++] = lc;
  for (i = 0; i < sizeof lonesome_lower / sizeof *lonesome_lower; i++)
    {
      wint_t li = lonesome_lower[i];
      if (li != lc && li != uc && li != c && towupper (li) == uc)
        folded[n++] = li;
    }
  return n;
}

typedef int predicate (int);





struct dfa_ctype
{
  const char *name;
  predicate *func;
  
# 914 "dfa.c" 3 4
 _Bool 
# 914 "dfa.c"
      single_byte_only;
};

static const struct dfa_ctype prednames[] = {
  {"alpha", isalpha, 
# 918 "dfa.c" 3 4
                    0
# 918 "dfa.c"
                         },
  {"upper", isupper, 
# 919 "dfa.c" 3 4
                    0
# 919 "dfa.c"
                         },
  {"lower", islower, 
# 920 "dfa.c" 3 4
                    0
# 920 "dfa.c"
                         },
  {"digit", isdigit, 
# 921 "dfa.c" 3 4
                    1
# 921 "dfa.c"
                        },
  {"xdigit", isxdigit, 
# 922 "dfa.c" 3 4
                      0
# 922 "dfa.c"
                           },
  {"space", isspace, 
# 923 "dfa.c" 3 4
                    0
# 923 "dfa.c"
                         },
  {"punct", ispunct, 
# 924 "dfa.c" 3 4
                    0
# 924 "dfa.c"
                         },
  {"alnum", isalnum, 
# 925 "dfa.c" 3 4
                    0
# 925 "dfa.c"
                         },
  {"print", isprint, 
# 926 "dfa.c" 3 4
                    0
# 926 "dfa.c"
                         },
  {"graph", isgraph, 
# 927 "dfa.c" 3 4
                    0
# 927 "dfa.c"
                         },
  {"cntrl", iscntrl, 
# 928 "dfa.c" 3 4
                    0
# 928 "dfa.c"
                         },
  {"blank", isblank, 
# 929 "dfa.c" 3 4
                    0
# 929 "dfa.c"
                         },
  {
# 930 "dfa.c" 3 4
  ((void *)0)
# 930 "dfa.c"
      , 
# 930 "dfa.c" 3 4
        ((void *)0)
# 930 "dfa.c"
            , 
# 930 "dfa.c" 3 4
              0
# 930 "dfa.c"
                   }
};

static const struct dfa_ctype *
# 933 "dfa.c" 3
                              __attribute__ ((__pure__))

# 934 "dfa.c"
find_pred (const char *str)
{
  unsigned int i;
  for (i = 0; prednames[i].name; ++i)
    if ((strcmp (str, prednames[i].name) == 0))
      return &prednames[i];
  return 
# 940 "dfa.c" 3 4
        ((void *)0)
# 940 "dfa.c"
            ;
}



static token
parse_bracket_exp (void)
{
  
# 948 "dfa.c" 3 4
 _Bool 
# 948 "dfa.c"
      invert;
  int c, c1, c2;
  charclass ccl;



  
# 954 "dfa.c" 3 4
 _Bool 
# 954 "dfa.c"
      known_bracket_exp = 
# 954 "dfa.c" 3 4
                          1
# 954 "dfa.c"
                              ;






  int colon_warning_state;

  wint_t wc;
  wint_t wc2;
  wint_t wc1 = 0;


  struct mb_char_classes *work_mbc;
  size_t chars_al;

  chars_al = 0;
  if (dfa->multibyte)
    {
      dfa->mbcsets = maybe_realloc (dfa->mbcsets, dfa->nmbcsets,
                                    &dfa->mbcsets_alloc,
                                    sizeof *dfa->mbcsets);






      work_mbc = &(dfa->mbcsets[dfa->nmbcsets++]);
      memset (work_mbc, 0, sizeof *work_mbc);
    }
  else
    work_mbc = 
# 987 "dfa.c" 3 4
              ((void *)0)
# 987 "dfa.c"
                  ;

  memset (ccl, 0, sizeof ccl);
  do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 990 "dfa.c" 3 4
 (-1)
# 990 "dfa.c"
 ; lexptr += nbytes; lexleft -= nbytes; } } while (0);
  if (c == '^')
    {
      do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 993 "dfa.c" 3 4
     (-1)
# 993 "dfa.c"
     ; lexptr += nbytes; lexleft -= nbytes; } } while (0);
      invert = 
# 994 "dfa.c" 3 4
              1
# 994 "dfa.c"
                  ;
      known_bracket_exp = using_simple_locale ();
    }
  else
    invert = 
# 998 "dfa.c" 3 4
            0
# 998 "dfa.c"
                 ;

  colon_warning_state = (c == ':');
  do
    {
      c1 = NOTCHAR;
      colon_warning_state &= ~2;





      if (c == '[')
        {
          do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc1) = _wc; (c1) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1012 "dfa.c" 3 4
         (-1)
# 1012 "dfa.c"
         ; lexptr += nbytes; lexleft -= nbytes; } } while (0);

          if ((c1 == ':' && (syntax_bits & ((((unsigned long int) 1) << 1) << 1)))
              || c1 == '.' || c1 == '=')
            {
              enum { MAX_BRACKET_STRING_LEN = 32 };
              char str[MAX_BRACKET_STRING_LEN + 1];
              size_t len = 0;
              for (;;)
                {
                  do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1022 "dfa.c" 3 4
                 (-1)
# 1022 "dfa.c"
                 ; lexptr += nbytes; lexleft -= nbytes; } } while (0);
                  if ((c == c1 && *lexptr == ']') || lexleft == 0)
                    break;
                  if (len < MAX_BRACKET_STRING_LEN)
                    str[len++] = c;
                  else

                    str[0] = '\0';
                }
              str[len] = '\0';


              do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1034 "dfa.c" 3 4
             (-1)
# 1034 "dfa.c"
             ; lexptr += nbytes; lexleft -= nbytes; } } while (0);
              if (c1 == ':')




                {
                  char const *class
                    = (case_fold && ((strcmp (str, "upper") == 0)
                                     || (strcmp (str, "lower") == 0)) ? "alpha" : str);
                  const struct dfa_ctype *pred = find_pred (class);
                  if (!pred)
                    dfaerror (gettext ("invalid character class"));

                  if (dfa->multibyte && !pred->single_byte_only)
                    known_bracket_exp = 
# 1049 "dfa.c" 3 4
                                       0
# 1049 "dfa.c"
                                            ;
                  else
                    for (c2 = 0; c2 < NOTCHAR; ++c2)
                      if (pred->func (c2))
                        setbit (c2, ccl);
                }
              else
                known_bracket_exp = 
# 1056 "dfa.c" 3 4
                                   0
# 1056 "dfa.c"
                                        ;

              colon_warning_state |= 8;


              do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc1) = _wc; (c1) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1061 "dfa.c" 3 4
             (-1)
# 1061 "dfa.c"
             ; lexptr += nbytes; lexleft -= nbytes; } } while (0);
              continue;
            }



        }

      if (c == '\\' && (syntax_bits & ((unsigned long int) 1)))
        do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1070 "dfa.c" 3 4
       (-1)
# 1070 "dfa.c"
       ; lexptr += nbytes; lexleft -= nbytes; } } while (0);

      if (c1 == NOTCHAR)
        do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc1) = _wc; (c1) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1073 "dfa.c" 3 4
       (-1)
# 1073 "dfa.c"
       ; lexptr += nbytes; lexleft -= nbytes; } } while (0);

      if (c1 == '-')

        {
          do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc2) = _wc; (c2) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1078 "dfa.c" 3 4
         (-1)
# 1078 "dfa.c"
         ; lexptr += nbytes; lexleft -= nbytes; } } while (0);




          if (c2 == '[' && *lexptr == '.')
            {
              known_bracket_exp = 
# 1085 "dfa.c" 3 4
                                 0
# 1085 "dfa.c"
                                      ;
              c2 = ']';
            }

          if (c2 == ']')
            {


              lexptr -= cur_mb_len;
              lexleft += cur_mb_len;
            }
          else
            {
              if (c2 == '\\' && (syntax_bits & ((unsigned long int) 1)))
                do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc2) = _wc; (c2) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1099 "dfa.c" 3 4
               (-1)
# 1099 "dfa.c"
               ; lexptr += nbytes; lexleft -= nbytes; } } while (0);

              colon_warning_state |= 8;
              do { if (! lexleft) { if ((gettext ("unbalanced [")) != 0) dfaerror (gettext ("unbalanced [")); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wc1) = _wc; (c1) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1102 "dfa.c" 3 4
             (-1)
# 1102 "dfa.c"
             ; lexptr += nbytes; lexleft -= nbytes; } } while (0);


              if (wc != wc2 || wc == 
# 1105 "dfa.c" 3 4
                                    (0xffffffffu)
# 1105 "dfa.c"
                                        )
                {
                  if (dfa->multibyte)
                    known_bracket_exp = 
# 1108 "dfa.c" 3 4
                                       0
# 1108 "dfa.c"
                                            ;
                  else if (using_simple_locale ())
                    {
                      int ci;
                      for (ci = c; ci <= c2; ci++)
                        setbit (ci, ccl);
                      if (case_fold)
                        {
                          int uc = toupper (c);
                          int uc2 = toupper (c2);
                          for (ci = 0; ci < NOTCHAR; ci++)
                            {
                              int uci = toupper (ci);
                              if (uc <= uci && uci <= uc2)
                                setbit (ci, ccl);
                            }
                        }
                    }
                  else
                    known_bracket_exp = 
# 1127 "dfa.c" 3 4
                                       0
# 1127 "dfa.c"
                                            ;

                  continue;
                }
            }
        }

      colon_warning_state |= (c == ':') ? 2 : 4;

      if (!dfa->multibyte)
        {
          if (case_fold)
            setbit_case_fold_c (c, ccl);
          else
            setbit (c, ccl);
          continue;
        }

      if (wc == 
# 1145 "dfa.c" 3 4
               (0xffffffffu)
# 1145 "dfa.c"
                   )
        known_bracket_exp = 
# 1146 "dfa.c" 3 4
                           0
# 1146 "dfa.c"
                                ;
      else
        {
          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];
          unsigned int i;
          unsigned int n = (case_fold
                            ? case_folded_counterparts (wc, folded + 1) + 1
                            : 1);
          folded[0] = wc;
          for (i = 0; i < n; i++)
            if (!setbit_wc (folded[i], ccl))
              {
                work_mbc->chars
                  = maybe_realloc (work_mbc->chars, work_mbc->nchars,
                                   &chars_al, sizeof *work_mbc->chars);
                work_mbc->chars[work_mbc->nchars++] = folded[i];
              }
        }
    }
  while ((wc = wc1, (c = c1) != ']'));

  if (colon_warning_state == 7)
    dfawarn (gettext ("character class syntax is [[:space:]], not [:space:]"));

  if (! known_bracket_exp)
    return BACKREF;

  if (dfa->multibyte)
    {
      static charclass zeroclass;
      work_mbc->invert = invert;
      work_mbc->cset = equal (ccl, zeroclass) ? -1 : charclass_index (ccl);
      return MBCSET;
    }

  if (invert)
    {
      
# 1183 "dfa.c" 3 4
     ((
# 1183 "dfa.c"
     !dfa->multibyte
# 1183 "dfa.c" 3 4
     ) ? (void) (0) : __assert_fail (
# 1183 "dfa.c"
     "!dfa->multibyte"
# 1183 "dfa.c" 3 4
     , "dfa.c", 1183, __PRETTY_FUNCTION__))
# 1183 "dfa.c"
                             ;
      notset (ccl);
      if (syntax_bits & ((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        clrbit ('\n', ccl);
    }

  return CSET + charclass_index (ccl);
}
# 1206 "dfa.c"
static token
lex (void)
{
  int c, c2;
  
# 1210 "dfa.c" 3 4
 _Bool 
# 1210 "dfa.c"
      backslash = 
# 1210 "dfa.c" 3 4
                  0
# 1210 "dfa.c"
                       ;
  charclass ccl;
  int i;







  for (i = 0; i < 2; ++i)
    {
      do { if (! lexleft) { if ((
# 1222 "dfa.c" 3 4
     ((void *)0)
# 1222 "dfa.c"
     ) != 0) dfaerror (
# 1222 "dfa.c" 3 4
     ((void *)0)
# 1222 "dfa.c"
     ); else return lasttok = END; } else { wint_t _wc; size_t nbytes = mbs_to_wchar (&_wc, lexptr, lexleft, dfa); cur_mb_len = nbytes; (wctok) = _wc; (c) = nbytes == 1 ? to_uchar (*lexptr) : 
# 1222 "dfa.c" 3 4
     (-1)
# 1222 "dfa.c"
     ; lexptr += nbytes; lexleft -= nbytes; } } while (0);

      switch (c)
        {
        case '\\':
          if (backslash)
            goto normal_char;
          if (lexleft == 0)
            dfaerror (gettext ("unfinished \\ escape"));
          backslash = 
# 1231 "dfa.c" 3 4
                     1
# 1231 "dfa.c"
                         ;
          break;

        case '^':
          if (backslash)
            goto normal_char;
          if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1)
              || lasttok == END || lasttok == LPAREN || lasttok == OR)
            return lasttok = BEGLINE;
          goto normal_char;

        case '$':
          if (backslash)
            goto normal_char;
          if (syntax_bits & (((((unsigned long int) 1) << 1) << 1) << 1)
              || lexleft == 0
              || (syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
                  ? lexleft > 0 && *lexptr == ')'
                  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
              || (syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
                  ? lexleft > 0 && *lexptr == '|'
                  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
              || ((syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                  && lexleft > 0 && *lexptr == '\n'))
            return lasttok = ENDLINE;
          goto normal_char;

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          if (backslash && !(syntax_bits & ((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            {
              laststart = 
# 1269 "dfa.c" 3 4
                         0
# 1269 "dfa.c"
                              ;
              return lasttok = BACKREF;
            }
          goto normal_char;

        case '`':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = BEGLINE;
          goto normal_char;

        case '\'':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = ENDLINE;
          goto normal_char;

        case '<':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = BEGWORD;
          goto normal_char;

        case '>':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = ENDWORD;
          goto normal_char;

        case 'b':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = LIMWORD;
          goto normal_char;

        case 'B':
          if (backslash && !(syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            return lasttok = NOTLIMWORD;
          goto normal_char;

        case '?':
          if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto normal_char;
          if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0))
            goto normal_char;
          if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
            goto normal_char;
          return lasttok = QMARK;

        case '*':
          if (backslash)
            goto normal_char;
          if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
            goto normal_char;
          return lasttok = STAR;

        case '+':
          if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto normal_char;
          if (backslash != ((syntax_bits & (((unsigned long int) 1) << 1)) != 0))
            goto normal_char;
          if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
            goto normal_char;
          return lasttok = PLUS;

        case '{':
          if (!(syntax_bits & (((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            goto normal_char;
          if (backslash != ((syntax_bits & ((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
            goto normal_char;
          if (!(syntax_bits & ((((((unsigned long int) 1) << 1) << 1) << 1) << 1)) && laststart)
            goto normal_char;







          {
            char const *p = lexptr;
            char const *lim = p + lexleft;
            minrep = maxrep = -1;
            for (; p != lim && ((unsigned) (*p) - '0' <= 9); p++)
              {
                if (minrep < 0)
                  minrep = *p - '0';
                else
                  minrep = ((
# 1352 "dfa.c" 3 4
                          (0x7fff) 
# 1352 "dfa.c"
                          + 1) < (minrep * 10 + *p - '0') ? (
# 1352 "dfa.c" 3 4
                          (0x7fff) 
# 1352 "dfa.c"
                          + 1) : (minrep * 10 + *p - '0'));
              }
            if (p != lim)
              {
                if (*p != ',')
                  maxrep = minrep;
                else
                  {
                    if (minrep < 0)
                      minrep = 0;
                    while (++p != lim && ((unsigned) (*p) - '0' <= 9))
                      {
                        if (maxrep < 0)
                          maxrep = *p - '0';
                        else
                          maxrep = ((
# 1367 "dfa.c" 3 4
                                  (0x7fff) 
# 1367 "dfa.c"
                                  + 1) < (maxrep * 10 + *p - '0') ? (
# 1367 "dfa.c" 3 4
                                  (0x7fff) 
# 1367 "dfa.c"
                                  + 1) : (maxrep * 10 + *p - '0'));
                      }
                  }
              }
            if (! ((! backslash || (p != lim && *p++ == '\\'))
                   && p != lim && *p++ == '}'
                   && 0 <= minrep && (maxrep < 0 || minrep <= maxrep)))
              {
                if (syntax_bits & (((((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
                  goto normal_char;
                dfaerror (gettext ("invalid content of \\{\\}"));
              }
            if (
# 1379 "dfa.c" 3 4
               (0x7fff) 
# 1379 "dfa.c"
                          < maxrep)
              dfaerror (gettext ("regular expression too big"));
            lexptr = p;
            lexleft = lim - p;
          }
          laststart = 
# 1384 "dfa.c" 3 4
                     0
# 1384 "dfa.c"
                          ;
          return lasttok = REPMN;

        case '|':
          if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto normal_char;
          if (backslash != ((syntax_bits & (((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
            goto normal_char;
          laststart = 
# 1392 "dfa.c" 3 4
                     1
# 1392 "dfa.c"
                         ;
          return lasttok = OR;

        case '\n':
          if (syntax_bits & ((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)
              || backslash || !(syntax_bits & (((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            goto normal_char;
          laststart = 
# 1399 "dfa.c" 3 4
                     1
# 1399 "dfa.c"
                         ;
          return lasttok = OR;

        case '(':
          if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
            goto normal_char;
          ++parens;
          laststart = 
# 1406 "dfa.c" 3 4
                     1
# 1406 "dfa.c"
                         ;
          return lasttok = LPAREN;

        case ')':
          if (backslash != ((syntax_bits & (((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
            goto normal_char;
          if (parens == 0 && syntax_bits & (((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            goto normal_char;
          --parens;
          laststart = 
# 1415 "dfa.c" 3 4
                     0
# 1415 "dfa.c"
                          ;
          return lasttok = RPAREN;

        case '.':
          if (backslash)
            goto normal_char;
          if (dfa->multibyte)
            {


              laststart = 
# 1425 "dfa.c" 3 4
                         0
# 1425 "dfa.c"
                              ;
              return lasttok = ANYCHAR;
            }
          zeroset (ccl);
          notset (ccl);
          if (!(syntax_bits & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            clrbit ('\n', ccl);
          if (syntax_bits & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
            clrbit ('\0', ccl);
          laststart = 
# 1434 "dfa.c" 3 4
                     0
# 1434 "dfa.c"
                          ;
          return lasttok = CSET + charclass_index (ccl);

        case 's':
        case 'S':
          if (!backslash || (syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            goto normal_char;
          if (!dfa->multibyte)
            {
              zeroset (ccl);
              for (c2 = 0; c2 < NOTCHAR; ++c2)
                if (
# 1445 "dfa.c" 3 4
                   ((*__ctype_b_loc ())[(int) ((
# 1445 "dfa.c"
                   c2
# 1445 "dfa.c" 3 4
                   ))] & (unsigned short int) _ISspace)
# 1445 "dfa.c"
                               )
                  setbit (c2, ccl);
              if (c == 'S')
                notset (ccl);
              laststart = 
# 1449 "dfa.c" 3 4
                         0
# 1449 "dfa.c"
                              ;
              return lasttok = CSET + charclass_index (ccl);
            }







          do { char const *lexptr_saved = lexptr; size_t lexleft_saved = lexleft; lexptr = (c == 's' ? "[:space:]]" : "^[:space:]]"); lexleft = strlen (lexptr);

          lasttok = parse_bracket_exp ();

          lexptr = lexptr_saved; lexleft = lexleft_saved; } while (0);

          laststart = 
# 1465 "dfa.c" 3 4
                     0
# 1465 "dfa.c"
                          ;
          return lasttok;

        case 'w':
        case 'W':
          if (!backslash || (syntax_bits & (((((((((((((((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
            goto normal_char;

          if (!dfa->multibyte)
            {
              zeroset (ccl);
              for (c2 = 0; c2 < NOTCHAR; ++c2)
                if (unibyte_word_constituent (c2))
                  setbit (c2, ccl);
              if (c == 'W')
                notset (ccl);
              laststart = 
# 1481 "dfa.c" 3 4
                         0
# 1481 "dfa.c"
                              ;
              return lasttok = CSET + charclass_index (ccl);
            }







          do { char const *lexptr_saved = lexptr; size_t lexleft_saved = lexleft; lexptr = (c == 'w' ? "_[:alnum:]]" : "^_[:alnum:]]"); lexleft = strlen (lexptr);

          lasttok = parse_bracket_exp ();

          lexptr = lexptr_saved; lexleft = lexleft_saved; } while (0);

          laststart = 
# 1497 "dfa.c" 3 4
                     0
# 1497 "dfa.c"
                          ;
          return lasttok;

        case '[':
          if (backslash)
            goto normal_char;
          laststart = 
# 1503 "dfa.c" 3 4
                     0
# 1503 "dfa.c"
                          ;
          return lasttok = parse_bracket_exp ();

        default:
        normal_char:
          laststart = 
# 1508 "dfa.c" 3 4
                     0
# 1508 "dfa.c"
                          ;


          if (dfa->multibyte)
            return lasttok = WCHAR;

          if (case_fold && 
# 1514 "dfa.c" 3 4
                          ((*__ctype_b_loc ())[(int) ((
# 1514 "dfa.c"
                          c
# 1514 "dfa.c" 3 4
                          ))] & (unsigned short int) _ISalpha)
# 1514 "dfa.c"
                                     )
            {
              zeroset (ccl);
              setbit_case_fold_c (c, ccl);
              return lasttok = CSET + charclass_index (ccl);
            }

          return lasttok = c;
        }
    }



  abort ();
  return END;
}



static token tok;
static size_t depth;





static void
addtok_mb (token t, int mbprop)
{
  if (dfa->talloc == dfa->tindex)
    {
      dfa->tokens = x2nrealloc (dfa->tokens, &dfa->talloc,
                                sizeof *dfa->tokens);
      if (dfa->multibyte)
        dfa->multibyte_prop = xnrealloc (dfa->multibyte_prop, dfa->talloc,
                                         sizeof *dfa->multibyte_prop);
    }
  if (dfa->multibyte)
    dfa->multibyte_prop[dfa->tindex] = mbprop;
  dfa->tokens[dfa->tindex++] = t;

  switch (t)
    {
    case QMARK:
    case STAR:
    case PLUS:
      break;

    case CAT:
    case OR:
      --depth;
      break;

    case BACKREF:
      dfa->fast = 
# 1568 "dfa.c" 3 4
                 0
# 1568 "dfa.c"
                      ;

    default:
      ++dfa->nleaves;

    case EMPTY:
      ++depth;
      break;
    }
  if (depth > dfa->depth)
    dfa->depth = depth;
}

static void addtok_wc (wint_t wc);



static void
addtok (token t)
{
  if (dfa->multibyte && t == MBCSET)
    {
      
# 1590 "dfa.c" 3 4
     _Bool 
# 1590 "dfa.c"
          need_or = 
# 1590 "dfa.c" 3 4
                    0
# 1590 "dfa.c"
                         ;
      struct mb_char_classes *work_mbc = &dfa->mbcsets[dfa->nmbcsets - 1];
      size_t i;



      for (i = 0; i < work_mbc->nchars; i++)
        {
          addtok_wc (work_mbc->chars[i]);
          if (need_or)
            addtok (OR);
          need_or = 
# 1601 "dfa.c" 3 4
                   1
# 1601 "dfa.c"
                       ;
        }
      work_mbc->nchars = 0;



      if (work_mbc->cset != -1)
        {
          addtok (CSET + work_mbc->cset);
          if (need_or)
            addtok (OR);
        }
    }
  else
    {
      addtok_mb (t, 3);
    }
}







static void
addtok_wc (wint_t wc)
{
  unsigned char buf[
# 1629 "dfa.c" 3 4
                   16
# 1629 "dfa.c"
                             ];
  mbstate_t s = { 0 };
  int i;
  size_t stored_bytes = wcrtomb ((char *) buf, wc, &s);

  if (stored_bytes != (size_t) -1)
    cur_mb_len = stored_bytes;
  else
    {


      cur_mb_len = 1;
      buf[0] = 0;
    }

  addtok_mb (buf[0], cur_mb_len == 1 ? 3 : 1);
  for (i = 1; i < cur_mb_len; i++)
    {
      addtok_mb (buf[i], i == cur_mb_len - 1 ? 2 : 0);
      addtok (CAT);
    }
}

static void
add_utf8_anychar (void)
{
  static charclass const utf8_classes[5] = {

    {0, 0, 0, 0, (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), 0, 0},


    {(((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1),
     (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), 0, 0, 0, 0},


    {0, 0, 0, 0, 0, 0, ~3 & (((charclass_word) 1 << (CHARCLASS_WORD_BITS - 1) << 1) - 1), 0},


    {0, 0, 0, 0, 0, 0, 0, 0xffff},


    {0, 0, 0, 0, 0, 0, 0, 0xff0000}
  };
  const unsigned int n = sizeof (utf8_classes) / sizeof (utf8_classes[0]);
  unsigned int i;


  if (dfa->utf8_anychar_classes[0] == 0)
    for (i = 0; i < n; i++)
      {
        charclass c;
        copyset (utf8_classes[i], c);
        if (i == 1)
          {
            if (!(syntax_bits & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
              clrbit ('\n', c);
            if (syntax_bits & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
              clrbit ('\0', c);
          }
        dfa->utf8_anychar_classes[i] = CSET + charclass_index (c);
      }
# 1701 "dfa.c"
  for (i = 1; i < n; i++)
    addtok (dfa->utf8_anychar_classes[i]);
  while (--i > 1)
    {
      addtok (dfa->utf8_anychar_classes[0]);
      addtok (CAT);
      addtok (OR);
    }
}
# 1746 "dfa.c"
static void
atom (void)
{
  if (tok == WCHAR)
    {
      if (wctok == 
# 1751 "dfa.c" 3 4
                  (0xffffffffu)
# 1751 "dfa.c"
                      )
        addtok (BACKREF);
      else
        {
          addtok_wc (wctok);

          if (case_fold)
            {
              wchar_t folded[CASE_FOLDED_BUFSIZE];
              unsigned int i, n = case_folded_counterparts (wctok, folded);
              for (i = 0; i < n; i++)
                {
                  addtok_wc (folded[i]);
                  addtok (OR);
                }
            }
        }

      tok = lex ();
    }
  else if (tok == ANYCHAR && using_utf8 ())
    {







      add_utf8_anychar ();
      tok = lex ();
    }
  else if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
           || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
           || tok == ANYCHAR || tok == MBCSET
           || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
    {
      addtok (tok);
      tok = lex ();
    }
  else if (tok == LPAREN)
    {
      tok = lex ();
      regexp ();
      if (tok != RPAREN)
        dfaerror (gettext ("unbalanced ("));
      tok = lex ();
    }
  else
    addtok (EMPTY);
}


static size_t 
# 1804 "dfa.c" 3
             __attribute__ ((__pure__))

# 1805 "dfa.c"
nsubtoks (size_t tindex)
{
  size_t ntoks1;

  switch (dfa->tokens[tindex - 1])
    {
    default:
      return 1;
    case QMARK:
    case STAR:
    case PLUS:
      return 1 + nsubtoks (tindex - 1);
    case CAT:
    case OR:
      ntoks1 = nsubtoks (tindex - 1);
      return 1 + ntoks1 + nsubtoks (tindex - 1 - ntoks1);
    }
}


static void
copytoks (size_t tindex, size_t ntokens)
{
  size_t i;

  if (dfa->multibyte)
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa->tokens[tindex + i], dfa->multibyte_prop[tindex + i]);
  else
    for (i = 0; i < ntokens; ++i)
      addtok_mb (dfa->tokens[tindex + i], 3);
}

static void
closure (void)
{
  int i;
  size_t tindex, ntokens;

  atom ();
  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
    if (tok == REPMN && (minrep || maxrep))
      {
        ntokens = nsubtoks (dfa->tindex);
        tindex = dfa->tindex - ntokens;
        if (maxrep < 0)
          addtok (PLUS);
        if (minrep == 0)
          addtok (QMARK);
        for (i = 1; i < minrep; ++i)
          {
            copytoks (tindex, ntokens);
            addtok (CAT);
          }
        for (; i < maxrep; ++i)
          {
            copytoks (tindex, ntokens);
            addtok (QMARK);
            addtok (CAT);
          }
        tok = lex ();
      }
    else if (tok == REPMN)
      {
        dfa->tindex -= nsubtoks (dfa->tindex);
        tok = lex ();
        closure ();
      }
    else
      {
        addtok (tok);
        tok = lex ();
      }
}

static void
branch (void)
{
  closure ();
  while (tok != RPAREN && tok != OR && tok >= 0)
    {
      closure ();
      addtok (CAT);
    }
}

static void
regexp (void)
{
  branch ();
  while (tok == OR)
    {
      tok = lex ();
      branch ();
      addtok (OR);
    }
}




void
dfaparse (char const *s, size_t len, struct dfa *d)
{
  dfa = d;
  lexptr = s;
  lexleft = len;
  lasttok = END;
  laststart = 
# 1913 "dfa.c" 3 4
             1
# 1913 "dfa.c"
                 ;
  parens = 0;
  if (dfa->multibyte)
    {
      cur_mb_len = 0;
      memset (&d->mbs, 0, sizeof d->mbs);
    }

  if (!syntax_bits_set)
    dfaerror (gettext ("no syntax specified"));

  tok = lex ();
  depth = d->depth;

  regexp ();

  if (tok != END)
    dfaerror (gettext ("unbalanced )"));

  addtok (END - d->nregexps);
  addtok (CAT);

  if (d->nregexps)
    addtok (OR);

  ++d->nregexps;
}




static void
copy (position_set const *src, position_set * dst)
{
  if (dst->alloc < src->nelem)
    {
      free (dst->elems);
      dst->alloc = src->nelem;
      dst->elems = x2nrealloc (
# 1951 "dfa.c" 3 4
                              ((void *)0)
# 1951 "dfa.c"
                                  , &dst->alloc, sizeof *dst->elems);
    }
  memcpy (dst->elems, src->elems, src->nelem * sizeof *dst->elems);
  dst->nelem = src->nelem;
}

static void
alloc_position_set (position_set * s, size_t size)
{
  s->elems = xnmalloc (size, sizeof *s->elems);
  s->alloc = size;
  s->nelem = 0;
}





static void
insert (position p, position_set * s)
{
  size_t count = s->nelem;
  size_t lo = 0, hi = count;
  size_t i;
  while (lo < hi)
    {
      size_t mid = (lo + hi) >> 1;
      if (s->elems[mid].index > p.index)
        lo = mid + 1;
      else
        hi = mid;
    }

  if (lo < count && p.index == s->elems[lo].index)
    {
      s->elems[lo].constraint |= p.constraint;
      return;
    }

  s->elems = maybe_realloc (s->elems, count, &s->alloc, sizeof *s->elems);
  for (i = count; i > lo; i--)
    s->elems[i] = s->elems[i - 1];
  s->elems[lo] = p;
  ++s->nelem;
}



static void
merge (position_set const *s1, position_set const *s2, position_set * m)
{
  size_t i = 0, j = 0;

  if (m->alloc < s1->nelem + s2->nelem)
    {
      free (m->elems);
      m->elems = maybe_realloc (
# 2007 "dfa.c" 3 4
                               ((void *)0)
# 2007 "dfa.c"
                                   , s1->nelem + s2->nelem, &m->alloc,
                                sizeof *m->elems);
    }
  m->nelem = 0;
  while (i < s1->nelem && j < s2->nelem)
    if (s1->elems[i].index > s2->elems[j].index)
      m->elems[m->nelem++] = s1->elems[i++];
    else if (s1->elems[i].index < s2->elems[j].index)
      m->elems[m->nelem++] = s2->elems[j++];
    else
      {
        m->elems[m->nelem] = s1->elems[i++];
        m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
      }
  while (i < s1->nelem)
    m->elems[m->nelem++] = s1->elems[i++];
  while (j < s2->nelem)
    m->elems[m->nelem++] = s2->elems[j++];
}


static void
delete (position p, position_set * s)
{
  size_t i;

  for (i = 0; i < s->nelem; ++i)
    if (p.index == s->elems[i].index)
      break;
  if (i < s->nelem)
    for (--s->nelem; i < s->nelem; ++i)
      s->elems[i] = s->elems[i + 1];
}




static state_num
state_index (struct dfa *d, position_set const *s, int context)
{
  size_t hash = 0;
  int constraint;
  state_num i, j;

  for (i = 0; i < s->nelem; ++i)
    hash ^= s->elems[i].index + s->elems[i].constraint;


  for (i = 0; i < d->sindex; ++i)
    {
      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
          || context != d->states[i].context)
        continue;
      for (j = 0; j < s->nelem; ++j)
        if (s->elems[j].constraint
            != d->states[i].elems.elems[j].constraint
            || s->elems[j].index != d->states[i].elems.elems[j].index)
          break;
      if (j == s->nelem)
        return i;
    }
# 2092 "dfa.c"
  d->states = maybe_realloc (d->states, d->sindex, &d->salloc,
                             sizeof *d->states);
  d->states[i].hash = hash;
  alloc_position_set (&d->states[i].elems, s->nelem);
  copy (s, &d->states[i].elems);
  d->states[i].context = context;
  d->states[i].constraint = 0;
  d->states[i].first_end = 0;
  d->states[i].mbps.nelem = 0;
  d->states[i].mbps.elems = 
# 2101 "dfa.c" 3 4
                           ((void *)0)
# 2101 "dfa.c"
                               ;

  for (j = 0; j < s->nelem; ++j)
    if (d->tokens[s->elems[j].index] < 0)
      {
        constraint = s->elems[j].constraint;
        if (((((7) & 1 ? ((constraint) & 0xf) : 0) | ((7) & 2 ? (((constraint) >> 4) & 0xf) : 0) | ((7) & 4 ? (((constraint) >> 8) & 0xf) : 0)) & (context)))
          d->states[i].constraint |= constraint;
        if (!d->states[i].first_end)
          d->states[i].first_end = d->tokens[s->elems[j].index];
      }
    else if (d->tokens[s->elems[j].index] == BACKREF)
      d->states[i].constraint = 0x777;

  ++d->sindex;

  return i;
}






static void
epsclosure (position_set *s, struct dfa const *d, char *visited)
{
  size_t i, j;
  position p, old;
  
# 2130 "dfa.c" 3 4
 _Bool 
# 2130 "dfa.c"
      initialized = 
# 2130 "dfa.c" 3 4
                    0
# 2130 "dfa.c"
                         ;

  for (i = 0; i < s->nelem; ++i)
    if (d->tokens[s->elems[i].index] >= NOTCHAR
        && d->tokens[s->elems[i].index] != BACKREF
        && d->tokens[s->elems[i].index] != ANYCHAR
        && d->tokens[s->elems[i].index] != MBCSET
        && d->tokens[s->elems[i].index] < CSET)
      {
        if (!initialized)
          {
            memset (visited, 0, d->tindex * sizeof (*visited));
            initialized = 
# 2142 "dfa.c" 3 4
                         1
# 2142 "dfa.c"
                             ;
          }
        old = s->elems[i];
        p.constraint = old.constraint;
        delete (s->elems[i], s);
        if (visited[old.index])
          {
            --i;
            continue;
          }
        visited[old.index] = 1;
        switch (d->tokens[old.index])
          {
          case BEGLINE:
            p.constraint &= 0x444;
            break;
          case ENDLINE:
            p.constraint &= 0x700;
            break;
          case BEGWORD:
            p.constraint &= 0x050;
            break;
          case ENDWORD:
            p.constraint &= 0x202;
            break;
          case LIMWORD:
            p.constraint &= 0x252;
            break;
          case NOTLIMWORD:
            p.constraint &= 0x525;
            break;
          default:
            break;
          }
        for (j = 0; j < d->follows[old.index].nelem; ++j)
          {
            p.index = d->follows[old.index].elems[j].index;
            insert (p, s);
          }

        i = -1;
      }
}




static int
charclass_context (charclass c)
{
  int context = 0;
  unsigned int j;

  if (tstbit (eolbyte, c))
    context |= 4;

  for (j = 0; j < CHARCLASS_WORDS; ++j)
    {
      if (c[j] & letters[j])
        context |= 2;
      if (c[j] & ~(letters[j] | newline[j]))
        context |= 1;
    }

  return context;
}







static int 
# 2215 "dfa.c" 3
          __attribute__ ((__pure__))

# 2216 "dfa.c"
state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  size_t j;

  for (j = 0; j < s->nelem; ++j)
    {
      if (((((s->elems[j].constraint) >> 2) & 0x111) != ((s->elems[j].constraint) & 0x111)))
        separate_contexts |= 4;
      if (((((s->elems[j].constraint) >> 1) & 0x111) != ((s->elems[j].constraint) & 0x111)))
        separate_contexts |= 2;
    }

  return separate_contexts;
}
# 2285 "dfa.c"
void
dfaanalyze (struct dfa *d, int searchflag)
{

  position *posalloc = xnmalloc (d->nleaves, 2 * sizeof *posalloc);

  position *firstpos = posalloc + d->nleaves;
  position *lastpos = firstpos + d->nleaves;


  struct
  {

    
# 2298 "dfa.c" 3 4
   _Bool 
# 2298 "dfa.c"
        nullable;


    size_t nfirstpos;
    size_t nlastpos;
  } *stkalloc = xnmalloc (d->depth, sizeof *stkalloc), *stk = stkalloc;

  position_set tmp;
  position_set merged;
  int separate_contexts;
  size_t i, j;
  position *pos;
  char *visited = xnmalloc (d->tindex, sizeof *visited);
# 2322 "dfa.c"
  d->searchflag = searchflag != 0;
  alloc_position_set (&merged, d->nleaves);
  d->follows = xcalloc (d->tindex, sizeof *d->follows);

  for (i = 0; i < d->tindex; ++i)
    {
      switch (d->tokens[i])
        {
        case EMPTY:

          stk->nullable = 
# 2332 "dfa.c" 3 4
                         1
# 2332 "dfa.c"
                             ;


          stk->nfirstpos = stk->nlastpos = 0;
          stk++;
          break;

        case STAR:
        case PLUS:


          tmp.nelem = stk[-1].nfirstpos;
          tmp.elems = firstpos;
          pos = lastpos;
          for (j = 0; j < stk[-1].nlastpos; ++j)
            {
              merge (&tmp, &d->follows[pos[j].index], &merged);
              copy (&merged, &d->follows[pos[j].index]);
            }


        case QMARK:

          if (d->tokens[i] != PLUS)
            stk[-1].nullable = 
# 2356 "dfa.c" 3 4
                              1
# 2356 "dfa.c"
                                  ;
          break;

        case CAT:


          tmp.nelem = stk[-1].nfirstpos;
          tmp.elems = firstpos;
          pos = lastpos + stk[-1].nlastpos;
          for (j = 0; j < stk[-2].nlastpos; ++j)
            {
              merge (&tmp, &d->follows[pos[j].index], &merged);
              copy (&merged, &d->follows[pos[j].index]);
            }



          if (stk[-2].nullable)
            stk[-2].nfirstpos += stk[-1].nfirstpos;
          else
            firstpos += stk[-1].nfirstpos;



          if (stk[-1].nullable)
            stk[-2].nlastpos += stk[-1].nlastpos;
          else
            {
              pos = lastpos + stk[-2].nlastpos;
              for (j = stk[-1].nlastpos; j-- > 0;)
                pos[j] = lastpos[j];
              lastpos += stk[-2].nlastpos;
              stk[-2].nlastpos = stk[-1].nlastpos;
            }


          stk[-2].nullable &= stk[-1].nullable;
          stk--;
          break;

        case OR:

          stk[-2].nfirstpos += stk[-1].nfirstpos;


          stk[-2].nlastpos += stk[-1].nlastpos;


          stk[-2].nullable |= stk[-1].nullable;
          stk--;
          break;

        default:





          stk->nullable = d->tokens[i] == BACKREF;


          stk->nfirstpos = stk->nlastpos = 1;
          stk++;

          --firstpos, --lastpos;
          firstpos->index = lastpos->index = i;
          firstpos->constraint = lastpos->constraint = 0x777;


          alloc_position_set (&d->follows[i], 1);
          break;
        }
# 2449 "dfa.c"
    }



  for (i = 0; i < d->tindex; ++i)
    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
        || d->tokens[i] == ANYCHAR || d->tokens[i] == MBCSET
        || d->tokens[i] >= CSET)
      {
# 2469 "dfa.c"
        copy (&d->follows[i], &merged);
        epsclosure (&merged, d, visited);
        copy (&merged, &d->follows[i]);
      }



  merged.nelem = 0;
  for (i = 0; i < stk[-1].nfirstpos; ++i)
    insert (firstpos[i], &merged);
  epsclosure (&merged, d, visited);


  separate_contexts = state_separate_contexts (&merged);
  if (separate_contexts & 4)
    state_index (d, &merged, 4);
  d->initstate_others = d->min_trcount
    = state_index (d, &merged, separate_contexts ^ 7);
  if (separate_contexts & 2)
    d->initstate_letter = d->min_trcount
      = state_index (d, &merged, 2);
  else
    d->initstate_letter = d->initstate_others;
  d->min_trcount++;

  free (posalloc);
  free (stkalloc);
  free (merged.elems);
  free (visited);
}
# 2531 "dfa.c"
void
dfastate (state_num s, struct dfa *d, state_num trans[])
{
  leaf_set grps[NOTCHAR];
  charclass labels[NOTCHAR];
  size_t ngrps = 0;
  position pos;
  charclass matches;
  charclass_word matchesf;
  charclass intersect;
  charclass_word intersectf;
  charclass leftovers;
  charclass_word leftoversf;
  position_set follows;
  position_set tmp;
  int possible_contexts;
  int separate_contexts;
  state_num state;
  state_num state_newline;
  state_num state_letter;
  
# 2551 "dfa.c" 3 4
 _Bool 
# 2551 "dfa.c"
      next_isnt_1st_byte = 
# 2551 "dfa.c" 3 4
                           0
# 2551 "dfa.c"
                                ;
  size_t i, j, k;





  zeroset (matches);

  for (i = 0; i < d->states[s].elems.nelem; ++i)
    {
      pos = d->states[s].elems.elems[i];
      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
        setbit (d->tokens[pos.index], matches);
      else if (d->tokens[pos.index] >= CSET)
        copyset (d->charclasses[d->tokens[pos.index] - CSET], matches);
      else
        {
          if (d->tokens[pos.index] == MBCSET
              || d->tokens[pos.index] == ANYCHAR)
            {



              if (d->states[s].mbps.nelem == 0)
                alloc_position_set (&d->states[s].mbps, 1);
              insert (pos, &(d->states[s].mbps));
            }
          continue;
        }



      if (pos.constraint != 0x777)
        {
          if (!((((4) & 1 ? ((pos.constraint) & 0xf) : 0) | ((4) & 2 ? (((pos.constraint) >> 4) & 0xf) : 0) | ((4) & 4 ? (((pos.constraint) >> 8) & 0xf) : 0)) & (d->states[s].context))
                                                                      )
            for (j = 0; j < CHARCLASS_WORDS; ++j)
              matches[j] &= ~newline[j];
          if (!((((2) & 1 ? ((pos.constraint) & 0xf) : 0) | ((2) & 2 ? (((pos.constraint) >> 4) & 0xf) : 0) | ((2) & 4 ? (((pos.constraint) >> 8) & 0xf) : 0)) & (d->states[s].context))
                                                                     )
            for (j = 0; j < CHARCLASS_WORDS; ++j)
              matches[j] &= ~letters[j];
          if (!((((1) & 1 ? ((pos.constraint) & 0xf) : 0) | ((1) & 2 ? (((pos.constraint) >> 4) & 0xf) : 0) | ((1) & 4 ? (((pos.constraint) >> 8) & 0xf) : 0)) & (d->states[s].context))
                                                                   )
            for (j = 0; j < CHARCLASS_WORDS; ++j)
              matches[j] &= letters[j] | newline[j];


          for (j = 0; j < CHARCLASS_WORDS && !matches[j]; ++j)
            continue;
          if (j == CHARCLASS_WORDS)
            continue;
        }
# 2616 "dfa.c"
      for (j = 0; j < ngrps; ++j)
        {



          if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
              && !tstbit (d->tokens[pos.index], labels[j]))
            continue;



          intersectf = 0;
          for (k = 0; k < CHARCLASS_WORDS; ++k)
            intersectf |= intersect[k] = matches[k] & labels[j][k];
          if (!intersectf)
            continue;


          leftoversf = matchesf = 0;
          for (k = 0; k < CHARCLASS_WORDS; ++k)
            {

              charclass_word match = matches[k], label = labels[j][k];

              leftoversf |= leftovers[k] = ~match & label;
              matchesf |= matches[k] = match & ~label;
            }


          if (leftoversf)
            {
              copyset (leftovers, labels[ngrps]);
              copyset (intersect, labels[j]);
              grps[ngrps].elems = xnmalloc (d->nleaves,
                                            sizeof *grps[ngrps].elems);
              memcpy (grps[ngrps].elems, grps[j].elems,
                      sizeof (grps[j].elems[0]) * grps[j].nelem);
              grps[ngrps].nelem = grps[j].nelem;
              ++ngrps;
            }



          grps[j].elems[grps[j].nelem++] = pos.index;



          if (!matchesf)
            break;
        }



      if (j == ngrps)
        {
          copyset (matches, labels[ngrps]);
          zeroset (matches);
          grps[ngrps].elems = xnmalloc (d->nleaves, sizeof *grps[ngrps].elems);
          grps[ngrps].nelem = 1;
          grps[ngrps].elems[0] = pos.index;
          ++ngrps;
        }
    }

  alloc_position_set (&follows, d->nleaves);
  alloc_position_set (&tmp, d->nleaves);




  if (d->searchflag)
    {

      copy (&d->states[0].elems, &follows);
      separate_contexts = state_separate_contexts (&follows);
      state = state_index (d, &follows, separate_contexts ^ 7);
      if (separate_contexts & 4)
        state_newline = state_index (d, &follows, 4);
      else
        state_newline = state;
      if (separate_contexts & 2)
        state_letter = state_index (d, &follows, 2);
      else
        state_letter = state;

      for (i = 0; i < NOTCHAR; ++i)
        trans[i] = unibyte_word_constituent (i) ? state_letter : state;
      trans[eolbyte] = state_newline;
    }
  else
    for (i = 0; i < NOTCHAR; ++i)
      trans[i] = -1;

  for (i = 0; i < ngrps; ++i)
    {
      follows.nelem = 0;



      for (j = 0; j < grps[i].nelem; ++j)
        for (k = 0; k < d->follows[grps[i].elems[j]].nelem; ++k)
          insert (d->follows[grps[i].elems[j]].elems[k], &follows);

      if (d->multibyte)
        {
# 2739 "dfa.c"
          next_isnt_1st_byte = 
# 2739 "dfa.c" 3 4
                              0
# 2739 "dfa.c"
                                   ;
          for (j = 0; j < follows.nelem; ++j)
            {
              if (!(d->multibyte_prop[follows.elems[j].index] & 1))
                {
                  next_isnt_1st_byte = 
# 2744 "dfa.c" 3 4
                                      1
# 2744 "dfa.c"
                                          ;
                  break;
                }
            }
        }



      if (d->searchflag && (!d->multibyte || !next_isnt_1st_byte))
        {
          merge (&d->states[0].elems, &follows, &tmp);
          copy (&tmp, &follows);
        }


      possible_contexts = charclass_context (labels[i]);
      separate_contexts = state_separate_contexts (&follows);


      if ((separate_contexts & possible_contexts) != possible_contexts)
        state = state_index (d, &follows, separate_contexts ^ 7);
      else
        state = -1;
      if (separate_contexts & possible_contexts & 4)
        state_newline = state_index (d, &follows, 4);
      else
        state_newline = state;
      if (separate_contexts & possible_contexts & 2)
        state_letter = state_index (d, &follows, 2);
      else
        state_letter = state;
# 2800 "dfa.c"
      for (j = 0; j < CHARCLASS_WORDS; ++j)
        for (k = 0; k < CHARCLASS_WORD_BITS; ++k)
          if (labels[i][j] >> k & 1)
            {
              int c = j * CHARCLASS_WORD_BITS + k;

              if (c == eolbyte)
                trans[c] = state_newline;
              else if (unibyte_word_constituent (c))
                trans[c] = state_letter;
              else if (c < NOTCHAR)
                trans[c] = state;
            }
    }
# 2826 "dfa.c"
  for (i = 0; i < ngrps; ++i)
    free (grps[i].elems);
  free (follows.elems);
  free (tmp.elems);
}


static void
realloc_trans_if_necessary (struct dfa *d, state_num new_state)
{
  state_num oldalloc = d->tralloc;
  if (oldalloc <= new_state)
    {
      state_num **realtrans = d->trans ? d->trans - 1 : 
# 2839 "dfa.c" 3 4
                                                       ((void *)0)
# 2839 "dfa.c"
                                                           ;
      size_t newalloc, newalloc1;
      newalloc1 = new_state + 1;
      realtrans = x2nrealloc (realtrans, &newalloc1, sizeof *realtrans);
      realtrans[0] = 
# 2843 "dfa.c" 3 4
                    ((void *)0)
# 2843 "dfa.c"
                        ;
      d->trans = realtrans + 1;
      d->tralloc = newalloc = newalloc1 - 1;
      d->fails = xnrealloc (d->fails, newalloc, sizeof *d->fails);
      d->success = xnrealloc (d->success, newalloc, sizeof *d->success);
      d->newlines = xnrealloc (d->newlines, newalloc, sizeof *d->newlines);
      for (; oldalloc < newalloc; oldalloc++)
        {
          d->trans[oldalloc] = 
# 2851 "dfa.c" 3 4
                              ((void *)0)
# 2851 "dfa.c"
                                  ;
          d->fails[oldalloc] = 
# 2852 "dfa.c" 3 4
                              ((void *)0)
# 2852 "dfa.c"
                                  ;
        }
    }
}
# 2864 "dfa.c"
static void
build_state (state_num s, struct dfa *d)
{
  state_num *trans;
  state_num i, maxstate;






  if (d->trcount >= 1024)
    {
      for (i = d->min_trcount; i < d->tralloc; ++i)
        {
          free (d->trans[i]);
          free (d->fails[i]);
          d->trans[i] = d->fails[i] = 
# 2881 "dfa.c" 3 4
                                     ((void *)0)
# 2881 "dfa.c"
                                         ;
        }
      d->trcount = d->min_trcount;
    }

  ++d->trcount;


  d->success[s] = 0;
  if (((((4) & 1 ? (((*d).states[s].constraint) & 0xf) : 0) | ((4) & 2 ? ((((*d).states[s].constraint) >> 4) & 0xf) : 0) | ((4) & 4 ? ((((*d).states[s].constraint) >> 8) & 0xf) : 0)) & (d->states[s].context)))
    d->success[s] |= 4;
  if (((((2) & 1 ? (((*d).states[s].constraint) & 0xf) : 0) | ((2) & 2 ? ((((*d).states[s].constraint) >> 4) & 0xf) : 0) | ((2) & 4 ? ((((*d).states[s].constraint) >> 8) & 0xf) : 0)) & (d->states[s].context)))
    d->success[s] |= 2;
  if (((((1) & 1 ? (((*d).states[s].constraint) & 0xf) : 0) | ((1) & 2 ? ((((*d).states[s].constraint) >> 4) & 0xf) : 0) | ((1) & 4 ? ((((*d).states[s].constraint) >> 8) & 0xf) : 0)) & (d->states[s].context)))
    d->success[s] |= 1;

  trans = xmalloc (NOTCHAR * sizeof *trans);
  dfastate (s, d, trans);




  maxstate = -1;
  for (i = 0; i < NOTCHAR; ++i)
    if (maxstate < trans[i])
      maxstate = trans[i];
  realloc_trans_if_necessary (d, maxstate);



  d->newlines[s] = trans[eolbyte];
  trans[eolbyte] = -1;

  if (((*d).states[s].constraint))
    d->fails[s] = trans;
  else
    d->trans[s] = trans;
}





typedef enum
{
  TRANSIT_STATE_IN_PROGRESS,
  TRANSIT_STATE_DONE,
  TRANSIT_STATE_END_BUFFER
} status_transit_state;





static status_transit_state
transit_state_singlebyte (struct dfa *d, state_num s, unsigned char const *p,
                          state_num * next_state)
{
  state_num *t;
  state_num works = s;

  status_transit_state rval = TRANSIT_STATE_IN_PROGRESS;

  while (rval == TRANSIT_STATE_IN_PROGRESS)
    {
      if ((t = d->trans[works]) != 
# 2946 "dfa.c" 3 4
                                  ((void *)0)
# 2946 "dfa.c"
                                      )
        {
          works = t[*p];
          rval = TRANSIT_STATE_DONE;
          if (works < 0)
            works = 0;
        }
      else if (works < 0)
        works = 0;
      else if (d->fails[works])
        {
          works = d->fails[works][*p];
          rval = TRANSIT_STATE_DONE;
        }
      else
        {
          build_state (works, d);
        }
    }
  *next_state = works;
  return rval;
}



static int
match_anychar (struct dfa *d, state_num s, position pos,
               wint_t wc, size_t mbclen)
{
  int context;


  if (wc == (wchar_t) '\n')
    {
      if (!(syntax_bits & ((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1)))
        return 0;
    }
  else if (wc == (wchar_t) '\0')
    {
      if (syntax_bits & (((((((((unsigned long int) 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        return 0;
    }
  else if (wc == 
# 2988 "dfa.c" 3 4
                (0xffffffffu)
# 2988 "dfa.c"
                    )
    return 0;

  context = wchar_context (wc);
  if (!((((context) & 1 ? ((pos.constraint) & 0xf) : 0) | ((context) & 2 ? (((pos.constraint) >> 4) & 0xf) : 0) | ((context) & 4 ? (((pos.constraint) >> 8) & 0xf) : 0)) & (d->states[s].context)))
    return 0;

  return mbclen;
}






static int *
check_matching_with_multibyte_ops (struct dfa *d, state_num s,
                                   char const *p, wint_t wc, size_t mbclen)
{
  size_t i;
  int *rarray;

  rarray = d->mb_match_lens;
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch (d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar (d, s, pos, wc, mbclen);
          break;
        default:
          break;
        }
    }
  return rarray;
}
# 3034 "dfa.c"
static status_transit_state
transit_state_consume_1char (struct dfa *d, state_num s,
                             unsigned char const **pp,
                             wint_t wc, size_t mbclen,
                             int *match_lens)
{
  size_t i, j;
  int k;
  state_num s1, s2;
  status_transit_state rs = TRANSIT_STATE_DONE;

  if (! match_lens && d->states[s].mbps.nelem != 0)
    match_lens = check_matching_with_multibyte_ops (d, s, (char const *) *pp,
                                                    wc, mbclen);



  s1 = s;
  for (k = 0; k < mbclen; k++)
    {
      s2 = s1;
      rs = transit_state_singlebyte (d, s2, (*pp)++, &s1);
    }
  copy (&d->states[s1].elems, &d->mb_follows);



  for (i = 0; i < d->states[s].mbps.nelem; i++)
    {
      if (match_lens[i] == mbclen)
        for (j = 0; j < d->follows[d->states[s].mbps.elems[i].index].nelem;
             j++)
          insert (d->follows[d->states[s].mbps.elems[i].index].elems[j],
                  &d->mb_follows);
    }


  return rs;
}




static state_num
transit_state (struct dfa *d, state_num s, unsigned char const **pp,
               unsigned char const *end)
{
  state_num s1;
  int mbclen;
  int maxlen = 0;
  size_t i, j;
  int *match_lens = 
# 3085 "dfa.c" 3 4
                   ((void *)0)
# 3085 "dfa.c"
                       ;
  size_t nelem = d->states[s].mbps.nelem;
  unsigned char const *p1 = *pp;
  wint_t wc;

  if (nelem > 0)


    {

      mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);
      match_lens = check_matching_with_multibyte_ops (d, s, (char const *) *pp,
                                                      wc, mbclen);

      for (i = 0; i < nelem; i++)


        {
          if (match_lens[i] > maxlen)
            maxlen = match_lens[i];
        }
    }

  if (nelem == 0 || maxlen == 0)


    {
      status_transit_state rs;
      rs = transit_state_singlebyte (d, s, *pp, &s1);


      if (rs == TRANSIT_STATE_DONE)
        ++*pp;

      return s1;
    }


  d->mb_follows.nelem = 0;





  transit_state_consume_1char (d, s, pp, wc, mbclen, match_lens);

  s1 = state_index (d, &d->mb_follows, wchar_context (wc));
  realloc_trans_if_necessary (d, s1);

  while (*pp - p1 < maxlen)
    {
      mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);
      transit_state_consume_1char (d, s1, pp, wc, mbclen, 
# 3137 "dfa.c" 3 4
                                                         ((void *)0)
# 3137 "dfa.c"
                                                             );

      for (i = 0; i < nelem; i++)
        {
          if (match_lens[i] == *pp - p1)
            for (j = 0;
                 j < d->follows[d->states[s1].mbps.elems[i].index].nelem; j++)
              insert (d->follows[d->states[s1].mbps.elems[i].index].elems[j],
                      &d->mb_follows);
        }

      s1 = state_index (d, &d->mb_follows, wchar_context (wc));
      realloc_trans_if_necessary (d, s1);
    }
  return s1;
}
# 3166 "dfa.c"
static unsigned char const *
skip_remains_mb (struct dfa *d, unsigned char const *p,
                 unsigned char const *mbp, char const *end, wint_t *wcp)
{
  wint_t wc = 
# 3170 "dfa.c" 3 4
             (0xffffffffu)
# 3170 "dfa.c"
                 ;
  while (mbp < p)
    mbp += mbs_to_wchar (&wc, (char const *) mbp,
                         end - (char const *) mbp, d);
  if (wcp != 
# 3174 "dfa.c" 3 4
            ((void *)0)
# 3174 "dfa.c"
                )
    *wcp = wc;
  return mbp;
}
# 3198 "dfa.c"
static inline char *
dfaexec_main (struct dfa *d, char const *begin, char *end, int allow_nl,
             size_t *count, 
# 3200 "dfa.c" 3 4
                           _Bool 
# 3200 "dfa.c"
                                multibyte)
{
  state_num s, s1;
  unsigned char const *p, *mbp;
  state_num **trans, *t;

  unsigned char eol = eolbyte;
  unsigned char saved_end;
  size_t nlcount = 0;

  if (!d->tralloc)
    {
      realloc_trans_if_necessary (d, 1);
      build_state (0, d);
    }

  s = s1 = 0;
  p = mbp = (unsigned char const *) begin;
  trans = d->trans;
  saved_end = *(unsigned char *) end;
  *end = eol;

  if (multibyte)
    {
      memset (&d->mbs, 0, sizeof d->mbs);
      if (! d->mb_match_lens)
        {
          d->mb_match_lens = xnmalloc (d->nleaves, sizeof *d->mb_match_lens);
          alloc_position_set (&d->mb_follows, d->nleaves);
        }
    }

  for (;;)
    {
      if (multibyte)
        {
          while ((t = trans[s]) != 
# 3236 "dfa.c" 3 4
                                  ((void *)0)
# 3236 "dfa.c"
                                      )
            {
              s1 = s;

              if (s < d->min_trcount)
                {
                  if (d->min_trcount == 1)
                    {
                      if (d->states[s].mbps.nelem == 0)
                        {
                          do
                            {
                              while (t[*p] == 0)
                                p++;
                              p = mbp = skip_remains_mb (d, p, mbp, end, 
# 3250 "dfa.c" 3 4
                                                                        ((void *)0)
# 3250 "dfa.c"
                                                                            );
                            }
                          while (t[*p] == 0);
                        }
                      else
                        p = mbp = skip_remains_mb (d, p, mbp, end, 
# 3255 "dfa.c" 3 4
                                                                  ((void *)0)
# 3255 "dfa.c"
                                                                      );
                    }
                  else
                    {
                      wint_t wc;
                      mbp = skip_remains_mb (d, p, mbp, end, &wc);



                      if (p < mbp)
                        {
                          int context = wchar_context (wc);
                          if (context == 2)
                            s = d->initstate_letter;
                          else



                            s = d->initstate_others;
                          p = mbp;
                          s1 = s;
                        }
                    }
                }

              if (d->states[s].mbps.nelem == 0)
                {
                  s = t[*p++];
                  continue;
                }
# 3317 "dfa.c"
              do { s = transit_state (d, s, &p, (unsigned char *) end); if (p[-1] == eol) { if ((char *) p > end) { p = 
# 3317 "dfa.c" 3 4
             ((void *)0)
# 3317 "dfa.c"
             ; goto done; } nlcount++; if (!allow_nl) s = 0; } mbp = p; trans = d->trans; } while (0);
            }
        }
      else
        {
          if (s == 0 && (t = trans[s]) != 
# 3322 "dfa.c" 3 4
                                         ((void *)0)
# 3322 "dfa.c"
                                             )
            {
              while (t[*p] == 0)
                p++;
              s1 = 0;
              s = t[*p++];
            }

          while ((t = trans[s]) != 
# 3330 "dfa.c" 3 4
                                  ((void *)0)
# 3330 "dfa.c"
                                      )
            {
              s1 = t[*p++];
              if ((t = trans[s1]) == 
# 3333 "dfa.c" 3 4
                                    ((void *)0)
# 3333 "dfa.c"
                                        )
                {
                  state_num tmp = s;
                  s = s1;
                  s1 = tmp;
                  break;
                }
              s = t[*p++];
            }
        }

      if (s < 0)
        {
          if ((char *) p > end || p[-1] != eol || d->newlines[s1] < 0)
            {
              p = 
# 3348 "dfa.c" 3 4
                 ((void *)0)
# 3348 "dfa.c"
                     ;
              goto done;
            }



          nlcount++;
          mbp = p;

          s = allow_nl ? d->newlines[s1] : 0;
        }

      if (d->fails[s])
        {
          if (d->success[s] & sbit[*p])
            goto done;

          s1 = s;
          if (multibyte)
            do { s = transit_state (d, s, &p, (unsigned char *) end); if (p[-1] == eol) { if ((char *) p > end) { p = 
# 3367 "dfa.c" 3 4
           ((void *)0)
# 3367 "dfa.c"
           ; goto done; } nlcount++; if (!allow_nl) s = 0; } mbp = p; trans = d->trans; } while (0);
          else
            s = d->fails[s][*p++];
        }
      else
        {
          if (!d->trans[s])
            build_state (s, d);
          trans = d->trans;
        }
    }

 done:
  if (count)
    *count += nlcount;
  *end = saved_end;
  return (char *) p;
}




static char *
dfaexec_mb (struct dfa *d, char const *begin, char *end,
            int allow_nl, size_t *count, int *backref)
{
  return dfaexec_main (d, begin, end, allow_nl, count, 
# 3393 "dfa.c" 3 4
                                                      1
# 3393 "dfa.c"
                                                          );
}

static char *
dfaexec_sb (struct dfa *d, char const *begin, char *end,
            int allow_nl, size_t *count, int *backref)
{
  return dfaexec_main (d, begin, end, allow_nl, count, 
# 3400 "dfa.c" 3 4
                                                      0
# 3400 "dfa.c"
                                                           );
}



static char *
dfaexec_noop (struct dfa *d, char const *begin, char *end,
              int allow_nl, size_t *count, int *backref)
{
  *backref = 1;
  return (char *) begin;
}




char *
dfaexec (struct dfa *d, char const *begin, char *end,
         int allow_nl, size_t *count, int *backref)
{
  return d->dfaexec (d, begin, end, allow_nl, count, backref);
}

struct dfa *
dfasuperset (struct dfa const *d)
{
  return d->superset;
}


# 3429 "dfa.c" 3 4
_Bool

# 3430 "dfa.c"
dfaisfast (struct dfa const *d)
{
  return d->fast;
}

static void
free_mbdata (struct dfa *d)
{
  size_t i;

  free (d->multibyte_prop);

  for (i = 0; i < d->nmbcsets; ++i)
    {
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free (p->chars);
    }

  free (d->mbcsets);
  free (d->mb_follows.elems);
  free (d->mb_match_lens);
  d->mb_match_lens = 
# 3451 "dfa.c" 3 4
                    ((void *)0)
# 3451 "dfa.c"
                        ;
}



void
dfainit (struct dfa *d)
{
  memset (d, 0, sizeof *d);
  d->multibyte = 
# 3460 "dfa.c" 3 4
                (__ctype_get_mb_cur_max ()) 
# 3460 "dfa.c"
                           > 1;
  d->dfaexec = d->multibyte ? dfaexec_mb : dfaexec_sb;
  d->fast = !d->multibyte;
}


static 
# 3466 "dfa.c" 3 4
      _Bool __attribute__ ((__pure__))

# 3467 "dfa.c"
dfa_supported (struct dfa const *d)
{
  for (size_t i = 0; i < d->tindex; i++)
    {
      switch (d->tokens[i])
        {
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
          if (!d->multibyte)
            continue;


        case BACKREF:
        case MBCSET:
          return 
# 3483 "dfa.c" 3 4
                0
# 3483 "dfa.c"
                     ;
        }
    }
  return 
# 3486 "dfa.c" 3 4
        1
# 3486 "dfa.c"
            ;
}

static void
dfaoptimize (struct dfa *d)
{
  size_t i;
  
# 3493 "dfa.c" 3 4
 _Bool 
# 3493 "dfa.c"
      have_backref = 
# 3493 "dfa.c" 3 4
                     0
# 3493 "dfa.c"
                          ;

  if (!using_utf8 ())
    return;

  for (i = 0; i < d->tindex; ++i)
    {
      switch (d->tokens[i])
        {
        case ANYCHAR:

          abort ();
        case BACKREF:
          have_backref = 
# 3506 "dfa.c" 3 4
                        1
# 3506 "dfa.c"
                            ;
          break;
        case MBCSET:

          return;
        default:
          break;
        }
    }

  if (!have_backref && d->superset)
    {

      dfafree (d->superset);
      free (d->superset);
      d->superset = 
# 3521 "dfa.c" 3 4
                   ((void *)0)
# 3521 "dfa.c"
                       ;
    }

  free_mbdata (d);
  d->multibyte = 
# 3525 "dfa.c" 3 4
                0
# 3525 "dfa.c"
                     ;
  d->dfaexec = dfaexec_sb;
}

static void
dfassbuild (struct dfa *d)
{
  size_t i, j;
  charclass ccl;
  
# 3534 "dfa.c" 3 4
 _Bool 
# 3534 "dfa.c"
      have_achar = 
# 3534 "dfa.c" 3 4
                   0
# 3534 "dfa.c"
                        ;
  
# 3535 "dfa.c" 3 4
 _Bool 
# 3535 "dfa.c"
      have_nchar = 
# 3535 "dfa.c" 3 4
                   0
# 3535 "dfa.c"
                        ;
  struct dfa *sup = dfaalloc ();

  *sup = *d;
  sup->multibyte = 
# 3539 "dfa.c" 3 4
                  0
# 3539 "dfa.c"
                       ;
  sup->dfaexec = dfaexec_sb;
  sup->multibyte_prop = 
# 3541 "dfa.c" 3 4
                       ((void *)0)
# 3541 "dfa.c"
                           ;
  sup->mbcsets = 
# 3542 "dfa.c" 3 4
                ((void *)0)
# 3542 "dfa.c"
                    ;
  sup->superset = 
# 3543 "dfa.c" 3 4
                 ((void *)0)
# 3543 "dfa.c"
                     ;
  sup->states = 
# 3544 "dfa.c" 3 4
               ((void *)0)
# 3544 "dfa.c"
                   ;
  sup->sindex = 0;
  sup->follows = 
# 3546 "dfa.c" 3 4
                ((void *)0)
# 3546 "dfa.c"
                    ;
  sup->tralloc = 0;
  sup->trans = 
# 3548 "dfa.c" 3 4
              ((void *)0)
# 3548 "dfa.c"
                  ;
  sup->fails = 
# 3549 "dfa.c" 3 4
              ((void *)0)
# 3549 "dfa.c"
                  ;
  sup->success = 
# 3550 "dfa.c" 3 4
                ((void *)0)
# 3550 "dfa.c"
                    ;
  sup->newlines = 
# 3551 "dfa.c" 3 4
                 ((void *)0)
# 3551 "dfa.c"
                     ;

  sup->charclasses = xnmalloc (sup->calloc, sizeof *sup->charclasses);
  if (d->cindex)
    {
      memcpy (sup->charclasses, d->charclasses,
              d->cindex * sizeof *sup->charclasses);
    }

  sup->tokens = xnmalloc (d->tindex, 2 * sizeof *sup->tokens);
  sup->talloc = d->tindex * 2;

  for (i = j = 0; i < d->tindex; i++)
    {
      switch (d->tokens[i])
        {
        case ANYCHAR:
        case MBCSET:
        case BACKREF:
          zeroset (ccl);
          notset (ccl);
          sup->tokens[j++] = CSET + dfa_charclass_index (sup, ccl);
          sup->tokens[j++] = STAR;
          if (d->tokens[i + 1] == QMARK || d->tokens[i + 1] == STAR
              || d->tokens[i + 1] == PLUS)
            i++;
          have_achar = 
# 3577 "dfa.c" 3 4
                      1
# 3577 "dfa.c"
                          ;
          break;
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
          if (d->multibyte)
            {


              sup->tokens[j++] = EMPTY;
              break;
            }
        default:
          sup->tokens[j++] = d->tokens[i];
          if ((0 <= d->tokens[i] && d->tokens[i] < NOTCHAR)
              || d->tokens[i] >= CSET)
            have_nchar = 
# 3594 "dfa.c" 3 4
                        1
# 3594 "dfa.c"
                            ;
          break;
        }
    }
  sup->tindex = j;

  if (have_nchar && (have_achar || d->multibyte))
    d->superset = sup;
  else
    {
      dfafree (sup);
      free (sup);
    }
}


void
dfacomp (char const *s, size_t len, struct dfa *d, int searchflag)
{
  dfainit (d);
  dfaparse (s, len, d);
  dfassbuild (d);

  if (dfa_supported (d))
    {
      dfaoptimize (d);
      dfaanalyze (d, searchflag);
    }
  else
    {
      d->dfaexec = dfaexec_noop;
    }

  if (d->superset)
    {
      d->fast = 
# 3629 "dfa.c" 3 4
               1
# 3629 "dfa.c"
                   ;
      dfaanalyze (d->superset, searchflag);
    }
}


void
dfafree (struct dfa *d)
{
  size_t i;

  free (d->charclasses);
  free (d->tokens);

  if (d->multibyte)
    free_mbdata (d);

  for (i = 0; i < d->sindex; ++i)
    {
      free (d->states[i].elems.elems);
      free (d->states[i].mbps.elems);
    }
  free (d->states);

  if (d->follows)
    {
      for (i = 0; i < d->tindex; ++i)
        free (d->follows[i].elems);
      free (d->follows);
    }

  if (d->trans)
    {
      for (i = 0; i < d->tralloc; ++i)
        {
          free (d->trans[i]);
          free (d->fails[i]);
        }

      free (d->trans - 1);
      free (d->fails);
      free (d->newlines);
      free (d->success);
    }

  if (d->superset)
    dfafree (d->superset);
}
# 3760 "dfa.c"
static char *
icatalloc (char *old, char const *new)
{
  char *result;
  size_t oldsize;
  size_t newsize = strlen (new);
  if (newsize == 0)
    return old;
  oldsize = strlen (old);
  result = xrealloc (old, oldsize + newsize + 1);
  memcpy (result + oldsize, new, newsize + 1);
  return result;
}

static void
freelist (char **cpp)
{
  while (*cpp)
    free (*cpp++);
}

static char **
enlist (char **cpp, char *new, size_t len)
{
  size_t i, j;
  new = memcpy (xmalloc (len + 1), new, len);
  new[len] = '\0';

  for (i = 0; cpp[i] != 
# 3788 "dfa.c" 3 4
                       ((void *)0)
# 3788 "dfa.c"
                           ; ++i)
    if (strstr (cpp[i], new) != 
# 3789 "dfa.c" 3 4
                               ((void *)0)
# 3789 "dfa.c"
                                   )
      {
        free (new);
        return cpp;
      }

  j = 0;
  while (cpp[j] != 
# 3796 "dfa.c" 3 4
                  ((void *)0)
# 3796 "dfa.c"
                      )
    if (strstr (new, cpp[j]) == 
# 3797 "dfa.c" 3 4
                               ((void *)0)
# 3797 "dfa.c"
                                   )
      ++j;
    else
      {
        free (cpp[j]);
        if (--i == j)
          break;
        cpp[j] = cpp[i];
        cpp[i] = 
# 3805 "dfa.c" 3 4
                ((void *)0)
# 3805 "dfa.c"
                    ;
      }

  cpp = xnrealloc (cpp, i + 2, sizeof *cpp);
  cpp[i] = new;
  cpp[i + 1] = 
# 3810 "dfa.c" 3 4
              ((void *)0)
# 3810 "dfa.c"
                  ;
  return cpp;
}



static char **
comsubs (char *left, char const *right)
{
  char **cpp = xzalloc (sizeof *cpp);
  char *lcp;

  for (lcp = left; *lcp != '\0'; ++lcp)
    {
      size_t len = 0;
      char *rcp = strchr (right, *lcp);
      while (rcp != 
# 3826 "dfa.c" 3 4
                   ((void *)0)
# 3826 "dfa.c"
                       )
        {
          size_t i;
          for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
            continue;
          if (i > len)
            len = i;
          rcp = strchr (rcp + 1, *lcp);
        }
      if (len != 0)
        cpp = enlist (cpp, lcp, len);
    }
  return cpp;
}

static char **
addlists (char **old, char **new)
{
  for (; *new; new++)
    old = enlist (old, *new, strlen (*new));
  return old;
}



static char **
inboth (char **left, char **right)
{
  char **both = xzalloc (sizeof *both);
  size_t lnum, rnum;

  for (lnum = 0; left[lnum] != 
# 3857 "dfa.c" 3 4
                              ((void *)0)
# 3857 "dfa.c"
                                  ; ++lnum)
    {
      for (rnum = 0; right[rnum] != 
# 3859 "dfa.c" 3 4
                                   ((void *)0)
# 3859 "dfa.c"
                                       ; ++rnum)
        {
          char **temp = comsubs (left[lnum], right[rnum]);
          both = addlists (both, temp);
          freelist (temp);
          free (temp);
        }
    }
  return both;
}

typedef struct must must;

struct must
{
  char **in;
  char *left;
  char *right;
  char *is;
  
# 3878 "dfa.c" 3 4
 _Bool 
# 3878 "dfa.c"
      begline;
  
# 3879 "dfa.c" 3 4
 _Bool 
# 3879 "dfa.c"
      endline;
  must *prev;
};

static must *
allocmust (must *mp, size_t size)
{
  must *new_mp = xmalloc (sizeof *new_mp);
  new_mp->in = xzalloc (sizeof *new_mp->in);
  new_mp->left = xzalloc (size);
  new_mp->right = xzalloc (size);
  new_mp->is = xzalloc (size);
  new_mp->begline = 
# 3891 "dfa.c" 3 4
                   0
# 3891 "dfa.c"
                        ;
  new_mp->endline = 
# 3892 "dfa.c" 3 4
                   0
# 3892 "dfa.c"
                        ;
  new_mp->prev = mp;
  return new_mp;
}

static void
resetmust (must *mp)
{
  freelist (mp->in);
  mp->in[0] = 
# 3901 "dfa.c" 3 4
             ((void *)0)
# 3901 "dfa.c"
                 ;
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  mp->begline = 
# 3903 "dfa.c" 3 4
               0
# 3903 "dfa.c"
                    ;
  mp->endline = 
# 3904 "dfa.c" 3 4
               0
# 3904 "dfa.c"
                    ;
}

static void
freemust (must *mp)
{
  freelist (mp->in);
  free (mp->in);
  free (mp->left);
  free (mp->right);
  free (mp->is);
  free (mp);
}

struct dfamust *
dfamust (struct dfa const *d)
{
  must *mp = 
# 3921 "dfa.c" 3 4
            ((void *)0)
# 3921 "dfa.c"
                ;
  char const *result = "";
  size_t i;
  
# 3924 "dfa.c" 3 4
 _Bool 
# 3924 "dfa.c"
      exact = 
# 3924 "dfa.c" 3 4
              0
# 3924 "dfa.c"
                   ;
  
# 3925 "dfa.c" 3 4
 _Bool 
# 3925 "dfa.c"
      begline = 
# 3925 "dfa.c" 3 4
                0
# 3925 "dfa.c"
                     ;
  
# 3926 "dfa.c" 3 4
 _Bool 
# 3926 "dfa.c"
      endline = 
# 3926 "dfa.c" 3 4
                0
# 3926 "dfa.c"
                     ;
  
# 3927 "dfa.c" 3 4
 _Bool 
# 3927 "dfa.c"
      need_begline = 
# 3927 "dfa.c" 3 4
                     0
# 3927 "dfa.c"
                          ;
  
# 3928 "dfa.c" 3 4
 _Bool 
# 3928 "dfa.c"
      need_endline = 
# 3928 "dfa.c" 3 4
                     0
# 3928 "dfa.c"
                          ;
  
# 3929 "dfa.c" 3 4
 _Bool 
# 3929 "dfa.c"
      case_fold_unibyte = case_fold && 
# 3929 "dfa.c" 3 4
                                       (__ctype_get_mb_cur_max ()) 
# 3929 "dfa.c"
                                                  == 1;

  for (size_t ri = 0; ri < d->tindex; ++ri)
    {
      token t = d->tokens[ri];
      switch (t)
        {
        case BEGLINE:
          mp = allocmust (mp, 2);
          mp->begline = 
# 3938 "dfa.c" 3 4
                       1
# 3938 "dfa.c"
                           ;
          need_begline = 
# 3939 "dfa.c" 3 4
                        1
# 3939 "dfa.c"
                            ;
          break;
        case ENDLINE:
          mp = allocmust (mp, 2);
          mp->endline = 
# 3943 "dfa.c" 3 4
                       1
# 3943 "dfa.c"
                           ;
          need_endline = 
# 3944 "dfa.c" 3 4
                        1
# 3944 "dfa.c"
                            ;
          break;
        case LPAREN:
        case RPAREN:
          
# 3948 "dfa.c" 3 4
         ((
# 3948 "dfa.c"
         !"neither LPAREN nor RPAREN may appear here"
# 3948 "dfa.c" 3 4
         ) ? (void) (0) : __assert_fail (
# 3948 "dfa.c"
         "!\"neither LPAREN nor RPAREN may appear here\""
# 3948 "dfa.c" 3 4
         , "dfa.c", 3948, __PRETTY_FUNCTION__))
# 3948 "dfa.c"
                                                              ;

        case EMPTY:
        case BEGWORD:
        case ENDWORD:
        case LIMWORD:
        case NOTLIMWORD:
        case BACKREF:
        case ANYCHAR:
        case MBCSET:
          mp = allocmust (mp, 2);
          break;

        case STAR:
        case QMARK:
          resetmust (mp);
          break;

        case OR:
          {
            char **new;
            must *rmp = mp;
            must *lmp = mp = mp->prev;
            size_t j, ln, rn, n;


            if ((strcmp (lmp->is, rmp->is) == 0))
              {
                lmp->begline &= rmp->begline;
                lmp->endline &= rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = 
# 3982 "dfa.c" 3 4
                              0
# 3982 "dfa.c"
                                   ;
                lmp->endline = 
# 3983 "dfa.c" 3 4
                              0
# 3983 "dfa.c"
                                   ;
              }

            i = 0;
            while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
              ++i;
            lmp->left[i] = '\0';

            ln = strlen (lmp->right);
            rn = strlen (rmp->right);
            n = ln;
            if (n > rn)
              n = rn;
            for (i = 0; i < n; ++i)
              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
                break;
            for (j = 0; j < i; ++j)
              lmp->right[j] = lmp->right[(ln - i) + j];
            lmp->right[j] = '\0';
            new = inboth (lmp->in, rmp->in);
            freelist (lmp->in);
            free (lmp->in);
            lmp->in = new;
            freemust (rmp);
          }
          break;

        case PLUS:
          mp->is[0] = '\0';
          break;

        case END:
          
# 4015 "dfa.c" 3 4
         ((
# 4015 "dfa.c"
         !mp->prev
# 4015 "dfa.c" 3 4
         ) ? (void) (0) : __assert_fail (
# 4015 "dfa.c"
         "!mp->prev"
# 4015 "dfa.c" 3 4
         , "dfa.c", 4015, __PRETTY_FUNCTION__))
# 4015 "dfa.c"
                           ;
          for (i = 0; mp->in[i] != 
# 4016 "dfa.c" 3 4
                                  ((void *)0)
# 4016 "dfa.c"
                                      ; ++i)
            if (strlen (mp->in[i]) > strlen (result))
              result = mp->in[i];
          if ((strcmp (result, mp->is) == 0))
            {
              if ((!need_begline || mp->begline) && (!need_endline
                                                     || mp->endline))
                exact = 
# 4023 "dfa.c" 3 4
                       1
# 4023 "dfa.c"
                           ;
              begline = mp->begline;
              endline = mp->endline;
            }
          goto done;

        case CAT:
          {
            must *rmp = mp;
            must *lmp = mp = mp->prev;




            lmp->in = addlists (lmp->in, rmp->in);
            if (lmp->right[0] != '\0' && rmp->left[0] != '\0')
              {
                size_t lrlen = strlen (lmp->right);
                size_t rllen = strlen (rmp->left);
                char *tp = xmalloc (lrlen + rllen);
                memcpy (tp, lmp->right, lrlen);
                memcpy (tp + lrlen, rmp->left, rllen);
                lmp->in = enlist (lmp->in, tp, lrlen + rllen);
                free (tp);
              }

            if (lmp->is[0] != '\0')
              lmp->left = icatalloc (lmp->left, rmp->left);

            if (rmp->is[0] == '\0')
              lmp->right[0] = '\0';
            lmp->right = icatalloc (lmp->right, rmp->right);

            if ((lmp->is[0] != '\0' || lmp->begline)
                && (rmp->is[0] != '\0' || rmp->endline))
              {
                lmp->is = icatalloc (lmp->is, rmp->is);
                lmp->endline = rmp->endline;
              }
            else
              {
                lmp->is[0] = '\0';
                lmp->begline = 
# 4065 "dfa.c" 3 4
                              0
# 4065 "dfa.c"
                                   ;
                lmp->endline = 
# 4066 "dfa.c" 3 4
                              0
# 4066 "dfa.c"
                                   ;
              }
            freemust (rmp);
          }
          break;

        case '\0':

          goto done;

        default:
          if (CSET <= t)
            {




              charclass *ccl = &d->charclasses[t - CSET];
              int j;
              for (j = 0; j < NOTCHAR; j++)
                if (tstbit (j, *ccl))
                  break;
              if (! (j < NOTCHAR))
                {
                  mp = allocmust (mp, 2);
                  break;
                }
              t = j;
              while (++j < NOTCHAR)
                if (tstbit (j, *ccl)
                    && ! (case_fold_unibyte
                          && toupper (j) == toupper (t)))
                  break;
              if (j < NOTCHAR)
                {
                  mp = allocmust (mp, 2);
                  break;
                }
            }

          size_t rj = ri + 2;
          if (d->tokens[ri + 1] == CAT)
            {
              for (; rj < d->tindex - 1; rj += 2)
                {
                  if ((rj != ri && (d->tokens[rj] <= 0
                                    || NOTCHAR <= d->tokens[rj]))
                      || d->tokens[rj + 1] != CAT)
                    break;
                }
            }
          mp = allocmust (mp, ((rj - ri) >> 1) + 1);
          mp->is[0] = mp->left[0] = mp->right[0]
            = case_fold_unibyte ? toupper (t) : t;

          for (i = 1; ri + 2 < rj; i++)
            {
              ri += 2;
              t = d->tokens[ri];
              mp->is[i] = mp->left[i] = mp->right[i]
                = case_fold_unibyte ? toupper (t) : t;
            }
          mp->is[i] = mp->left[i] = mp->right[i] = '\0';
          mp->in = enlist (mp->in, mp->is, i);
          break;
        }
    }
 done:;

  struct dfamust *dm = 
# 4135 "dfa.c" 3 4
                      ((void *)0)
# 4135 "dfa.c"
                          ;
  if (*result)
    {
      dm = xmalloc (sizeof *dm);
      dm->exact = exact;
      dm->begline = begline;
      dm->endline = endline;
      dm->must = xstrdup (result);
    }

  while (mp)
    {
      must *prev = mp->prev;
      freemust (mp);
      mp = prev;
    }

  return dm;
}

void
dfamustfree (struct dfamust *dm)
{
  free (dm->must);
  free (dm);
}

struct dfa *
dfaalloc (void)
{
  return xmalloc (sizeof (struct dfa));
}
